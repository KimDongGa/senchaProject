# app.json 수정 시 sencha app build를 실행시켜야 한다. #


1. App 아키텍처 소개
	: Ext JS는 MVC와 MVVM 어플리케이션 아키텍처를 동시에 지원한다. 
	어플리케이션 코드를 논리적으로 분할한다는 관점과 컨셉으로 생각하자면 이 두가지 아키텍처는 분명히 공유하는 점이 많다고 할 수 있다.
	아키텍처 각가의 방법론적 접근은 어플리케이션을 어떤 관점에서 분할 할 것인가에 대한 차이만 있다고 할 수 있다.
	
1-2. MVC 
	: MVC 아키텍처에서 대부분의 클래스는 모델(Model), 뷰(View) 또는 컨트롤러(Controller)에 속한다.
	사용자는 모델에 의해 수집되거나 처리된 데이터를 화면에 그려주는 뷰를 통해 어플리케이션과 상호작용을 수행하게 된다.
	뷰와 사용자와의 상호작용은 컨트롤러에 의해 감시되고, 필요하다면 뷰와 모델을 업데이트 한다.
	
	: 뷰와 모델은 컨트롤러가 중간에 개입하여 업데이트를 중재하기 때문에 직접 서로 간섭하는 일이 드물다.
	일반적으로 컨트롤러는 MVC 어플리케이션에서 대부분의 어플리케이션 로직을 담고 있다. 
	이상적인 경우 뷰는 비즈니스 로직을 거의 갖고 있지 않아야 한다.
	모델은 데이터와 인터페이스가 주요 역할로서 데이터의 변경에 대한 비즈니스 로직을 담당한다.
	
	: 목적 - 어플리케이션에서 각 클래스의 역할을 간결하고 명확하게 정의하는 것이다.
			모든 클래스의 역할이 명확하게 정의되어 있을 경우 대형 어플리케이션 개발환경에서 클래스가 이리저리 꼬이는 모호함을 최소화 할수 있을 것이다.
			이것은 결국 어플리케이션 시험과 유지보수를 쉽게 하고 코드의 재사용성을 높이는 결과를 기대할 수 있다.
	  
1-3. MVVM 
	: MVC와 MVVM의 가장 핵심적인 차이점은 MVVM에서 뷰 모델(ViewModel)이라고 불리는 뷰의 추상화를 지원한다는 점.
	 뷰 모델은 "데이터 바인딩(data binding)"이라는 기수을 사용해서 모델의 데이터와 뷰가 그리는 화면상의 데이터의 변경을 중재한다.
	 
1-4. MVC와 MVVM
	: 어플리케이션에 적합한 아키텍처를 선택할 때 이해를 돕기 위해, 우선 먼저 몇가지 정의를 짚고 갈 필요가 있다.
		1) (M) Model : 어플리케이션에서 사용되는 데이터를 담당
		   			  "Models"라고 불리는 데이터 집합으로 필드와 데이터로 정의된다. 예를 들어 User 모델은 user-name과 password 필드를 갖는다.
		   			  모델은 데이터 패키지를 통해 데이터에 대한 추적을 유지하고 결합(associations)을 통해 다른 모델들과 연결된다.
		   			  모델은 일반적으로 그리드 또는 다른 컴포넌트에 데이터를 제공하기 위한 스토어(Store)와 결합하여 사용되며, 
		   			  또한 validation, conversion 기타 등등 데이터를 취급하다보면 필요할 수 잇는 모든 데이터 로직의 이상적인 장소라고 할 수 있다.
		2) (V) View : 뷰는 화면에 그려지는 비주얼에 관련된 모든 컴포넌트라고 할 수 있다.
					 그리드, 트리, 패널 등 화면에 나타나는 모든 것을 뷰
	    3) (C) Controller : 어플리케이션이 작동하기 위해 필요한 뷰 로직을 관리한다. 
	    				   이에 따라 뷰를 랜더링 하고, 라우팅하거나 모델 인스턴스를 생성하거나 또는 다른 어플리 케이션 로직 일부를 수행토록 한다.
	    4) (VM) ViewModel : 뷰 모델은 뷰로 제공되는 뷰로 제공되는 데이터를 특정하여 관리하기 위한 클래스로서 컴포넌트가 바인딩을 처리하거나 데이터 변경에 따라 업데이트 되도록 하는 역할을 담당한다. 
	    				   이러한 어플리케이션 아키텍처는 코드의 구조화 및 일관성르 부여한다.
	    5) 모든 어플리케이션은 같은 방식으로 동작한다.

1-5. Sencha Cmd
	명령어 : - sencha generate app -ext Study ./app
		   - cd app
		   - sencha app watch 
1-6. 파일 구조 :
	- Ext JS 어플리케이션은 모두 단일화된 폴더 구조를 따른다. 권고하는 파일 배치는 모든 클래스들은 app폴더에 저장하는 것이다. 
	  이 폴더는 어플리케이션 네임스페이스 하위의 모델, 스토어 및 뷰 엘리먼트들을 서브 폴더로 포함하게 된다.
	  뷰, 뷰 컨트롤러, 뷰 모델과 같은 뷰 엘리먼트들은 한 곳에 묶어서 저장한다.
	- 구조
		app
			Application
			>model
				Readme.md
			Readme.md
			>store
				Readme.md
			>view
				>main
					Main.js
					MainController.js
					MainModel.js
			app.js
			app.json
			bootstrap.css
			bootstrap.js
			bootstrap.json
			>build
			build.xml
			>ext
			index.html
			>overrides
			>packages
			Readme.md
			>resources
			>sass	

1-7. 네임스페이스 : 각 클래스의 첫번째 라인은 정렬 순서를 의미한다.
	- (AppName).(foldname).(ClassAndFileName)


1-8. app.js : Application.js 파일 내부에서 생성한 클래스를 app.js에서 인스턴스를 실행
	ex)
		Ext.application({
			name : 'Study',
			
			extend: 'Study.Application',
			
			autoCreateViewport :'Study.view.main.Main'  //-> autoCreateViewport는 Ext JS 5의 새로운기능 :
														//	1. autoCreateViewport에 컨테이너 클래스를 설정하게 되면 뷰 포트로 어떤 클래스드니 사용할 수 있게 된다.
															2. autoCreateViewport 설정은 어플리케이션에게 지정된 뷰를 생성하고 뷰포트 플러그인을 덧붙이도록 지시 => 이렇나 동작은 뷰를 document body에 연결하게 된다.			
		})
		
1-9. Application.js	: - 모든 JS 어플리케이션은 Application 클래스의 인스턴스부터 시작된다. 
					  - 이 클래스는 app.js에 의해 인스턴스가 생성되어 실해오딘다. 아래의 Application.js의 내용은 Sencha Cmd가 자동으로 생성한 것이다.
					  - 아래의 Application.js의 내용은 Sencha Cmd가 자동으로 생성된 것이다.
						ex)
							Ext.define('Study.Application',{ 
								
								extend:'Ext.app.Application',
								name:'Study',
								stores: [
									
								],
								launch: function(){
									
								}
							
							})
						# Application 클래스는 어플리케이션의 Global 설정, 즉 네임스페이스, 공유 스토어 등을 포함한다.

1-10. Views	:- 뷰는 Ext.Component의 서브 클래스인 컴포넌트 그 이상도 그 이하도 아니라고 할 수 있다.
			 - 뷰는 어픞리케이션의 모든 비주얼적 측면을 포함하낟.
			 - "main"폴더의 Main.js파일 
				ex)
					Ext.define('Study.view.main.Main',{
						extend : 'Ext.container.Container',
						xtype : 'app-main',
						controller : 'main',
						viewModel : {
							type : 'main'
						},
						items : [{
							xtype : 'panel',
							bind : {
								title : '{name}'
							},
							region : 'west',
							html : '<ul>...</ul>'
							width : 250,
							split : true,
							sbar : [{
								text : 'Button',
								handler : 'onClickButton'
							}]
						},{
							region : 'center',
							xtype : 'tabpanel',
							items:[{
								title : 'Tab 1',
								html : '<h2>Content ...</h2>'
							}]				
						}]			
					})
				# 뷰에 어플리케이션 로직이 포함되어 있지 않은 점에 주목 
				- 뷰에 관련한 모든 로직은 뷰 컨트롤러에 포함되어야 한다.
				- 예제에서의 뷰는 border 레이아웃을 겆는 컨테이너로서 west와 center 영역을 갖는다.
				 이 영역들은 버튼이 포함도니 툴 바가 위치한 패털과 단일 탭을 갖는 탭 패널을 포함한다. 
				 좀 더 자세한 사항은 Getting Started Guide를 참고
				
				
1-11. 컨트롤러 설정
	- 컨트롤러 설정에서는 뷰를 위한 뷰 모델 지정을 수행한다. 
	- 뷰 컨트롤러가 뷰에 대해 지정되면 이벤트 핸들러와 래퍼런스를 위한 컨테이너로 변화
	- 이러한 사실은 결국 뷰 컨트롤러와 뷰에서 이벤트를 발생시키는 컴포넌트가 1-대-1 관계를 갖는다는 뜻.
	
1-12. 뷰 모델 설정
	- 뷰 모델 설정은 뷰에 대한 뷰 모델을 지정하는 것
	- 뷰 모델은 컴포넌트와 하우 ㅣ뷰에 대한 데이터를 제공하는 역할을 담당한다. 뷰 모델에 담긴 데이터는 컴포넌트와 바인딩 설정에 따라 화면에 전시되거나 편집될 목적으로 사용되는 것이 일반적
	
1-13. 컨트롤러 (Controller)		
	
	ex)
		Ext.define('Study.view.amin.MainController',{
			extend : 'Ext.app.ViewController',
			requires: [
				'Ext.MessageBox'
			],
			alias : 'controller.main',
			onClickButton : function() {
				Ext.Msg.confirm('Confirm', 'Are you sure', 'onConfirm', this);
			},
			onConfirm : function(){
				if(choice === 'yes'){
				}
			}
		})		
		
	- 뷰 모델 설정은 뷰에 대한 뷰 모델을 지정하는 것		
	- 어플리케이션 뷰를 정의한 Main.js로 돌아가서 살펴본다면 tbar button의 핸들러 처리를 위한 함수가 지정되 있음을 알수 있다.
	- 뷰에 속한 컴포넌트의 이벤트 핸들러인 onClickButton함수는 바로 이 컨트롤러에 정의되어 있다.
	- 컨트롤러는 별다른 특별한 설정이 없이 이벤트를 처리할 준비가 되어 있다.
	- 이런 점은 어플리케이션에 매우 쉽게 로직을 추가할 수 있게 된다.
	- onClickButton함수에 필요한 몯느 것ㅇ느 여기에 구현하면 되는데 바로 컨트롤러가 뷰와 1대1관계로 대응하기 때문
	- 목적 
		: 1. "listeners"와 "reference" 설정을 이용한 뷰와 연결
		  2. 연결된 뷰 컨틀롤러를 자동으로 관리함으로서 뷰의 생명주기를 연장, 인스턴스 생성부터 소멸에 이르기까지 Ext.app.ViewwController는 
		  	컴포넌트와 이를 참조하는 뷰 컨트롤러를 묶어주는데 같은 뷰 클래스의 두번째 인스턴스는 자신만의 뷰 컨트롤러 인스턴스를 갖게 된다. 
		  	 이러한 뷰가 소멸될 때 연결된 뷰 컨트롤러 인스턴스 역시 같이 소멸
		  3. 중첩된 뷰의 직관성을 위한 추상화 제공
	
1-14. 뷰 모델
	
	ex) 
		Ext.define('Study.view.main.MainModel',{
			extend : 'Ext.app.ViewModel',
			alias : 'viewmodel.main',
			data: {
				name:'Study'				
			}
		})
	- 뷰 모델은 데이터 객체를 관리하는 클래스이다.
	- 이 클래스는 뷰가 사용할 데이터를 바인딩하고 데이터가 수정되었을 때 알리는 역할을 수행한다.
	- 뷰 컨트롤러와 유사하게 뷰 모델은 래퍼러스를 이용해서 뷰에 연결된다. 뷰 모델이 뷰와 연결되어 있기 때문에 컴포넌트 계층구조의 조상 컴포넌트에 의해 
	 소유된 상위 부모 뷰 모델과 연결되는 것 역시 가능하다. 
	- 이러기에 자식 뷰는 간단하게 부모 뷰 모델의 데이터를 "상속"할 수 있다.
	- Main.js의 뷰 모델 설정을 이용해서 뷰와 뷰 모델의 연결을 생성하였다. 이 연결은 뷰 모델로부터 뷰로 서넝ㄴ적인 형태로서 데이터르 자동으로 설정하기 위한 Setter와 설정을 
	바인딩할 수 있도록 한다. MainModel.js에서 인라인 코딩 되어 있는 데이터를 참고

1-15. Model과 Store
	- 모델과 스토어는 어플리케이션에서 정보의 게이트웨이 역할을 담당한다. 거의 대부분의 데이터는 이 두 클래스에 의 해 "모델화"되거나, 조직화 되거나 또는 보내고 받게 된다.
	- 모델
		1). Ext.data.Model은 어플리케이션에서 지속가능한 모든 형태의 데이터를 대표한다.
		2). 각 모델은 어플리케이션에 대해 "모델"데이터를 제공하기 위한 필드와 함수를 갖는다.
		3). 모델은 가장 일바넉으로 스토어와 결합하여 사용되는데, 스토어는 그리드, 트리 및 차트와 같이 데이터와 함께 사용되는 컴포넌트에 의해 사용된다.
		
			ex)
				Ext.define('Study.model.User',{
					extend:'Ext.data.Model',
					fields:[
						{name:'name', type:'string'},
						{name:'age', type:'int'}
					]
				} 
		# 앞서 네임스페이스 섹션에서 설명한 바와 같이 위 코드는 app/model 폴더에 User.js 파일로 저장되어야 한다.		
	- 필드
		1). Ext.data.Model은 담고 있는 값을 의미하는 레코드 또는 "fields"라고 불리는 속성을 기술한다.
		2). 모델 클래스는 이러한 필드를 "fields"설정을 이용해 정의

1-16. 스토어
	- 스토어는 클라이언트 측면에서 레코드(모델 클래스의 인스턴스)의 캐시라고 할 수 있다.
	- 스토어는 담고 있는 데이터에 대한 정렬(Sorting), 필터링 및 질의(Querying)기능을 제공한다.
		ex)
			Ext.define('Study.store.User',{
				extend : 'Ext.data.Store',
				model : 'Study.model.User',
				data : [
					{firstName : 'Sech', age: '34'},
					{firstName : 'Scott', age: '72'},
					{firstName : 'Gary', age: '19'},
					{firstName : 'Capybara', age: '208'}
				]
			})
		# 위 코드는 app/store 폴더에 User.js 파일로 저장해야 한다. 
		 이렇게 정의된 스코어는 Application.js의 스토어 설정을 통해 스토어를 그롤벌 인스턴스로 설정할 수 있다.
		 -> Application.js의 스토어 설정은 다음과 같다
		 	ex)
		 		stores: [
		 			'User'
		 		],
			# 예제에서 스토어는 직접 인라인 코딩된 데이터를 포함하고 있는데, 대부분의 실제 어플리케이션을 구현할 때는 모델 또는 스토어에서 프록시를 이용해 데이터를 획득하게 된다. 
			 프록시는 데이터 제공자와 어플리케이션간에 데이터 전송을 수행한다.	
	
2. 뷰 컨트롤러 : Ext JS 5는 어플리케이션 아키텍처를 사용함에 있어서 몇가지 주목할만한 발전을 이뤄냈다. MVC 어플리케이션에서의 뷰 컨트로럴와 MVVM 모델과 뷰 모델을 지원하기 시작한 것이다.
			 이들 중 가장 괄목할 만한 점은 이러한 아키텍처의 선택이 상호 배타적이지 않기 때문에 일부 기능을 점진적으로 사용하거나, 혹은 뒤썩어서 사용할 수 도 있다는 점이다.
			 
2-1. 컨트롤러의 개선
	: Ext JS 4에서 컨트롤러는 Ext.app.Controller를 파생한 클래스로 CSS와 유사한 선택자, 즉 컴포넌트 쿼리를 사용하여 컴포넌트를 찾고 해당 컴포넌트의 이벤트를 처리했다.
	 또한 컴포넌트 인스턴스를 선택하거나 넘겨받기 위해 "refs"를 사용했다.
	 
	: 이러한 컨트롤러는 어플리케이션 실행 시 생성되어 어플리케이션이 실행되는 동안 유지되었다. 컨트롤어의 생명주기 동안 뷰에서 발생하는 이번트들이 컨트롤러를 통해 들어오고 나간다.
	 또한 컨컨틀러가 관리하는 뷰는 다중 인스턴스가 될 수도 있었다.
	 
2-2. 뷰 컨트롤러
	: Ext JS 5가 현재 버전의 컨트롤러에 대한 하향 호환성를 유지하면서, 위에서 설명한 문제를 해결하기 위한 방안으로 Ext.app.ViewComtroller라는 새로운 컨트롤러를 소개하고 있다.
		- "listener"와 "reference"설정을 사용하여 뷰와 연결을 간소화 함
		- 연결된 뷰 컨트롤러에 대한 자동 관리를 위한 뷰의 생명주기 연동
		- 관리하는 뷰와 1:1 관계에 기반한 뷰 컨트롤러를 통해 복잡성 제거
		- 중첩된 뷰의 신뢰성 제고를 위한 캡슐화 지원
		- 컴포넌트 선택 및 연결도니 뷰의 게층에 상관없는 이벤트 리스닝 유지
		
		1) 리스너 
			: 리스너 설정은 새롭게 도입된 것으로 Ext JS 5에서 몇가지 새로운 능력을 부여한다.
			 뷰 컨트롤러의 목적을 위해 다음 두가지 샘플을 살펴보자. 
			 첫번째 뷰의 자식 아이템에서 리스너를 사용하느 기본적 사용이다.
			 
			 ex) 
			 	 Ext.define('Study.view.foo.Foo',{
			 	 	extend : 'Ext.panel.Panel',
			 	 	xtype : 'foo',
			 	 	controller : 'foo',
			 	 	items : [{
			 	 		xtype : 'textfield',
			 	 		fieldLabel : 'Bar',
			 	 		listeners: {
			 	 			change : 'onBarChange'
			 	 		}
			 	 	}]
			 	 });
			 	 
			 	 Ext.define('Study.view.foo.FooController',{
			 	 	extend : 'Ext.app.ViewController',
			 	 	alias : 'controller.foo',
			 	 	onBarChange : function(){
			 	 	
			 	 	}
			 	 });
				# 위 예제 코드에서 리스너는 "scope"를 특정하지 않는 "onBarChange"라는 이름의 이벤트 핸들러를 보여주고 있다.
				 내부적으로 이벤트 시스템은 Bar textfield의 기본 범위를 해당 뷰 컨트롤러 자체로 해석한다.
				   
	
	
	
	
	
	