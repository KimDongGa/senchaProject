# app.json 수정 시 sencha app build를 실행시켜야 한다. #


1. App 아키텍처 소개
	: Ext JS는 MVC와 MVVM 어플리케이션 아키텍처를 동시에 지원한다. 
	어플리케이션 코드를 논리적으로 분할한다는 관점과 컨셉으로 생각하자면 이 두가지 아키텍처는 분명히 공유하는 점이 많다고 할 수 있다.
	아키텍처 각가의 방법론적 접근은 어플리케이션을 어떤 관점에서 분할 할 것인가에 대한 차이만 있다고 할 수 있다.
	
1-2. MVC 
	: MVC 아키텍처에서 대부분의 클래스는 모델(Model), 뷰(View) 또는 컨트롤러(Controller)에 속한다.
	사용자는 모델에 의해 수집되거나 처리된 데이터를 화면에 그려주는 뷰를 통해 어플리케이션과 상호작용을 수행하게 된다.
	뷰와 사용자와의 상호작용은 컨트롤러에 의해 감시되고, 필요하다면 뷰와 모델을 업데이트 한다.
	
	: 뷰와 모델은 컨트롤러가 중간에 개입하여 업데이트를 중재하기 때문에 직접 서로 간섭하는 일이 드물다.
	일반적으로 컨트롤러는 MVC 어플리케이션에서 대부분의 어플리케이션 로직을 담고 있다. 
	이상적인 경우 뷰는 비즈니스 로직을 거의 갖고 있지 않아야 한다.
	모델은 데이터와 인터페이스가 주요 역할로서 데이터의 변경에 대한 비즈니스 로직을 담당한다.
	
	: 목적 - 어플리케이션에서 각 클래스의 역할을 간결하고 명확하게 정의하는 것이다.
			모든 클래스의 역할이 명확하게 정의되어 있을 경우 대형 어플리케이션 개발환경에서 클래스가 이리저리 꼬이는 모호함을 최소화 할수 있을 것이다.
			이것은 결국 어플리케이션 시험과 유지보수를 쉽게 하고 코드의 재사용성을 높이는 결과를 기대할 수 있다.
	  
1-3. MVVM 
	: MVC와 MVVM의 가장 핵심적인 차이점은 MVVM에서 뷰 모델(ViewModel)이라고 불리는 뷰의 추상화를 지원한다는 점.
	 뷰 모델은 "데이터 바인딩(data binding)"이라는 기수을 사용해서 모델의 데이터와 뷰가 그리는 화면상의 데이터의 변경을 중재한다.
	 
1-4. MVC와 MVVM
	: 어플리케이션에 적합한 아키텍처를 선택할 때 이해를 돕기 위해, 우선 먼저 몇가지 정의를 짚고 갈 필요가 있다.
		1) (M) Model : 어플리케이션에서 사용되는 데이터를 담당
		   			  "Models"라고 불리는 데이터 집합으로 필드와 데이터로 정의된다. 예를 들어 User 모델은 user-name과 password 필드를 갖는다.
		   			  모델은 데이터 패키지를 통해 데이터에 대한 추적을 유지하고 결합(associations)을 통해 다른 모델들과 연결된다.
		   			  모델은 일반적으로 그리드 또는 다른 컴포넌트에 데이터를 제공하기 위한 스토어(Store)와 결합하여 사용되며, 
		   			  또한 validation, conversion 기타 등등 데이터를 취급하다보면 필요할 수 잇는 모든 데이터 로직의 이상적인 장소라고 할 수 있다.
		2) (V) View : 뷰는 화면에 그려지는 비주얼에 관련된 모든 컴포넌트라고 할 수 있다.
					 그리드, 트리, 패널 등 화면에 나타나는 모든 것을 뷰
	    3) (C) Controller : 어플리케이션이 작동하기 위해 필요한 뷰 로직을 관리한다. 
	    				   이에 따라 뷰를 랜더링 하고, 라우팅하거나 모델 인스턴스를 생성하거나 또는 다른 어플리 케이션 로직 일부를 수행토록 한다.
	    4) (VM) ViewModel : 뷰 모델은 뷰로 제공되는 뷰로 제공되는 데이터를 특정하여 관리하기 위한 클래스로서 컴포넌트가 바인딩을 처리하거나 데이터 변경에 따라 업데이트 되도록 하는 역할을 담당한다. 
	    				   이러한 어플리케이션 아키텍처는 코드의 구조화 및 일관성르 부여한다.
	    5) 모든 어플리케이션은 같은 방식으로 동작한다.

1-5. Sencha Cmd
	명령어 : - sencha generate app -ext Study ./app
		   - cd app
		   - sencha app watch 
1-6. 파일 구조 :
	- Ext JS 어플리케이션은 모두 단일화된 폴더 구조를 따른다. 권고하는 파일 배치는 모든 클래스들은 app폴더에 저장하는 것이다. 
	  이 폴더는 어플리케이션 네임스페이스 하위의 모델, 스토어 및 뷰 엘리먼트들을 서브 폴더로 포함하게 된다.
	  뷰, 뷰 컨트롤러, 뷰 모델과 같은 뷰 엘리먼트들은 한 곳에 묶어서 저장한다.
	- 구조
		app
			Application
			>model
				Readme.md
			Readme.md
			>store
				Readme.md
			>view
				>main
					Main.js
					MainController.js
					MainModel.js
			app.js
			app.json
			bootstrap.css
			bootstrap.js
			bootstrap.json
			>build
			build.xml
			>ext
			index.html
			>overrides
			>packages
			Readme.md
			>resources
			>sass	

1-7. 네임스페이스 : 각 클래스의 첫번째 라인은 정렬 순서를 의미한다.
	- (AppName).(foldname).(ClassAndFileName)


1-8. app.js : Application.js 파일 내부에서 생성한 클래스를 app.js에서 인스턴스를 실행
	ex)
		Ext.application({
			name : 'Study',
			
			extend: 'Study.Application',
			
			autoCreateViewport :'Study.view.main.Main'  //-> autoCreateViewport는 Ext JS 5의 새로운기능 :
														//	1. autoCreateViewport에 컨테이너 클래스를 설정하게 되면 뷰 포트로 어떤 클래스드니 사용할 수 있게 된다.
															2. autoCreateViewport 설정은 어플리케이션에게 지정된 뷰를 생성하고 뷰포트 플러그인을 덧붙이도록 지시 => 이렇나 동작은 뷰를 document body에 연결하게 된다.			
		})
		
1-9. Application.js	: - 모든 JS 어플리케이션은 Application 클래스의 인스턴스부터 시작된다. 
					  - 이 클래스는 app.js에 의해 인스턴스가 생성되어 실해오딘다. 아래의 Application.js의 내용은 Sencha Cmd가 자동으로 생성한 것이다.
					  - 아래의 Application.js의 내용은 Sencha Cmd가 자동으로 생성된 것이다.
						ex)
							Ext.define('Study.Application',{ 
								
								extend:'Ext.app.Application',
								name:'Study',
								stores: [
									
								],
								launch: function(){
									
								}
							
							})
						# Application 클래스는 어플리케이션의 Global 설정, 즉 네임스페이스, 공유 스토어 등을 포함한다.

1-10. Views	:- 뷰는 Ext.Component의 서브 클래스인 컴포넌트 그 이상도 그 이하도 아니라고 할 수 있다.
			 - 뷰는 어픞리케이션의 모든 비주얼적 측면을 포함하낟.
			 - "main"폴더의 Main.js파일 
				ex)
					Ext.define('Study.view.main.Main',{
						extend : 'Ext.container.Container',
						xtype : 'app-main',
						controller : 'main',
						viewModel : {
							type : 'main'
						},
						items : [{
							xtype : 'panel',
							bind : {
								title : '{name}'
							},
							region : 'west',
							html : '<ul>...</ul>'
							width : 250,
							split : true,
							sbar : [{
								text : 'Button',
								handler : 'onClickButton'
							}]
						},{
							region : 'center',
							xtype : 'tabpanel',
							items:[{
								title : 'Tab 1',
								html : '<h2>Content ...</h2>'
							}]				
						}]			
					})
				# 뷰에 어플리케이션 로직이 포함되어 있지 않은 점에 주목 
				- 뷰에 관련한 모든 로직은 뷰 컨트롤러에 포함되어야 한다.
				- 예제에서의 뷰는 border 레이아웃을 겆는 컨테이너로서 west와 center 영역을 갖는다.
				 이 영역들은 버튼이 포함도니 툴 바가 위치한 패털과 단일 탭을 갖는 탭 패널을 포함한다. 
				 좀 더 자세한 사항은 Getting Started Guide를 참고
				
				
1-11. 컨트롤러 설정
	- 컨트롤러 설정에서는 뷰를 위한 뷰 모델 지정을 수행한다. 
	- 뷰 컨트롤러가 뷰에 대해 지정되면 이벤트 핸들러와 래퍼런스를 위한 컨테이너로 변화
	- 이러한 사실은 결국 뷰 컨트롤러와 뷰에서 이벤트를 발생시키는 컴포넌트가 1-대-1 관계를 갖는다는 뜻.
	
1-12. 뷰 모델 설정
	- 뷰 모델 설정은 뷰에 대한 뷰 모델을 지정하는 것
	- 뷰 모델은 컴포넌트와 하우 ㅣ뷰에 대한 데이터를 제공하는 역할을 담당한다. 뷰 모델에 담긴 데이터는 컴포넌트와 바인딩 설정에 따라 화면에 전시되거나 편집될 목적으로 사용되는 것이 일반적
	
1-13. 컨트롤러 (Controller)		
	
	ex)
		Ext.define('Study.view.amin.MainController',{
			extend : 'Ext.app.ViewController',
			requires: [
				'Ext.MessageBox'
			],
			alias : 'controller.main',
			onClickButton : function() {
				Ext.Msg.confirm('Confirm', 'Are you sure', 'onConfirm', this);
			},
			onConfirm : function(){
				if(choice === 'yes'){
				}
			}
		})		
		
	- 뷰 모델 설정은 뷰에 대한 뷰 모델을 지정하는 것		
	- 어플리케이션 뷰를 정의한 Main.js로 돌아가서 살펴본다면 tbar button의 핸들러 처리를 위한 함수가 지정되 있음을 알수 있다.
	- 뷰에 속한 컴포넌트의 이벤트 핸들러인 onClickButton함수는 바로 이 컨트롤러에 정의되어 있다.
	- 컨트롤러는 별다른 특별한 설정이 없이 이벤트를 처리할 준비가 되어 있다.
	- 이런 점은 어플리케이션에 매우 쉽게 로직을 추가할 수 있게 된다.
	- onClickButton함수에 필요한 몯느 것ㅇ느 여기에 구현하면 되는데 바로 컨트롤러가 뷰와 1대1관계로 대응하기 때문
	- 목적 
		: 1. "listeners"와 "reference" 설정을 이용한 뷰와 연결
		  2. 연결된 뷰 컨틀롤러를 자동으로 관리함으로서 뷰의 생명주기를 연장, 인스턴스 생성부터 소멸에 이르기까지 Ext.app.ViewwController는 
		  	컴포넌트와 이를 참조하는 뷰 컨트롤러를 묶어주는데 같은 뷰 클래스의 두번째 인스턴스는 자신만의 뷰 컨트롤러 인스턴스를 갖게 된다. 
		  	 이러한 뷰가 소멸될 때 연결된 뷰 컨트롤러 인스턴스 역시 같이 소멸
		  3. 중첩된 뷰의 직관성을 위한 추상화 제공
	
1-14. 뷰 모델
	
	ex) 
		Ext.define('Study.view.main.MainModel',{
			extend : 'Ext.app.ViewModel',
			alias : 'viewmodel.main',
			data: {
				name:'Study'				
			}
		})
	- 뷰 모델은 데이터 객체를 관리하는 클래스이다.
	- 이 클래스는 뷰가 사용할 데이터를 바인딩하고 데이터가 수정되었을 때 알리는 역할을 수행한다.
	- 뷰 컨트롤러와 유사하게 뷰 모델은 래퍼러스를 이용해서 뷰에 연결된다. 뷰 모델이 뷰와 연결되어 있기 때문에 컴포넌트 계층구조의 조상 컴포넌트에 의해 
	 소유된 상위 부모 뷰 모델과 연결되는 것 역시 가능하다. 
	- 이러기에 자식 뷰는 간단하게 부모 뷰 모델의 데이터를 "상속"할 수 있다.
	- Main.js의 뷰 모델 설정을 이용해서 뷰와 뷰 모델의 연결을 생성하였다. 이 연결은 뷰 모델로부터 뷰로 서넝ㄴ적인 형태로서 데이터르 자동으로 설정하기 위한 Setter와 설정을 
	바인딩할 수 있도록 한다. MainModel.js에서 인라인 코딩 되어 있는 데이터를 참고

1-15. Model과 Store
	- 모델과 스토어는 어플리케이션에서 정보의 게이트웨이 역할을 담당한다. 거의 대부분의 데이터는 이 두 클래스에 의 해 "모델화"되거나, 조직화 되거나 또는 보내고 받게 된다.
	- 모델
		1). Ext.data.Model은 어플리케이션에서 지속가능한 모든 형태의 데이터를 대표한다.
		2). 각 모델은 어플리케이션에 대해 "모델"데이터를 제공하기 위한 필드와 함수를 갖는다.
		3). 모델은 가장 일바넉으로 스토어와 결합하여 사용되는데, 스토어는 그리드, 트리 및 차트와 같이 데이터와 함께 사용되는 컴포넌트에 의해 사용된다.
		
			ex)
				Ext.define('Study.model.User',{
					extend:'Ext.data.Model',
					fields:[
						{name:'name', type:'string'},
						{name:'age', type:'int'}
					]
				} 
		# 앞서 네임스페이스 섹션에서 설명한 바와 같이 위 코드는 app/model 폴더에 User.js 파일로 저장되어야 한다.		
	- 필드
		1). Ext.data.Model은 담고 있는 값을 의미하는 레코드 또는 "fields"라고 불리는 속성을 기술한다.
		2). 모델 클래스는 이러한 필드를 "fields"설정을 이용해 정의

1-16. 스토어
	- 스토어는 클라이언트 측면에서 레코드(모델 클래스의 인스턴스)의 캐시라고 할 수 있다.
	- 스토어는 담고 있는 데이터에 대한 정렬(Sorting), 필터링 및 질의(Querying)기능을 제공한다.
		ex)
			Ext.define('Study.store.User',{
				extend : 'Ext.data.Store',
				model : 'Study.model.User',
				data : [
					{firstName : 'Sech', age: '34'},
					{firstName : 'Scott', age: '72'},
					{firstName : 'Gary', age: '19'},
					{firstName : 'Capybara', age: '208'}
				]
			})
		# 위 코드는 app/store 폴더에 User.js 파일로 저장해야 한다. 
		 이렇게 정의된 스코어는 Application.js의 스토어 설정을 통해 스토어를 그롤벌 인스턴스로 설정할 수 있다.
		 -> Application.js의 스토어 설정은 다음과 같다
		 	ex)
		 		stores: [
		 			'User'
		 		],
			# 예제에서 스토어는 직접 인라인 코딩된 데이터를 포함하고 있는데, 대부분의 실제 어플리케이션을 구현할 때는 모델 또는 스토어에서 프록시를 이용해 데이터를 획득하게 된다. 
			 프록시는 데이터 제공자와 어플리케이션간에 데이터 전송을 수행한다.	
	
2. 뷰 컨트롤러 : Ext JS 5는 어플리케이션 아키텍처를 사용함에 있어서 몇가지 주목할만한 발전을 이뤄냈다. MVC 어플리케이션에서의 뷰 컨트로럴와 MVVM 모델과 뷰 모델을 지원하기 시작한 것이다.
			 이들 중 가장 괄목할 만한 점은 이러한 아키텍처의 선택이 상호 배타적이지 않기 때문에 일부 기능을 점진적으로 사용하거나, 혹은 뒤썩어서 사용할 수 도 있다는 점이다.
			 
2-1. 컨트롤러의 개선
	: Ext JS 4에서 컨트롤러는 Ext.app.Controller를 파생한 클래스로 CSS와 유사한 선택자, 즉 컴포넌트 쿼리를 사용하여 컴포넌트를 찾고 해당 컴포넌트의 이벤트를 처리했다.
	 또한 컴포넌트 인스턴스를 선택하거나 넘겨받기 위해 "refs"를 사용했다.
	 
	: 이러한 컨트롤러는 어플리케이션 실행 시 생성되어 어플리케이션이 실행되는 동안 유지되었다. 컨트롤어의 생명주기 동안 뷰에서 발생하는 이번트들이 컨트롤러를 통해 들어오고 나간다.
	 또한 컨컨틀러가 관리하는 뷰는 다중 인스턴스가 될 수도 있었다.
	 
2-2. 뷰 컨트롤러
	: Ext JS 5가 현재 버전의 컨트롤러에 대한 하향 호환성를 유지하면서, 위에서 설명한 문제를 해결하기 위한 방안으로 Ext.app.ViewComtroller라는 새로운 컨트롤러를 소개하고 있다.
		- "listener"와 "reference"설정을 사용하여 뷰와 연결을 간소화 함
		- 연결된 뷰 컨트롤러에 대한 자동 관리를 위한 뷰의 생명주기 연동
		- 관리하는 뷰와 1:1 관계에 기반한 뷰 컨트롤러를 통해 복잡성 제거
		- 중첩된 뷰의 신뢰성 제고를 위한 캡슐화 지원
		- 컴포넌트 선택 및 연결도니 뷰의 게층에 상관없는 이벤트 리스닝 유지
		
		1) 리스너 
			: 리스너 설정은 새롭게 도입된 것으로 Ext JS 5에서 몇가지 새로운 능력을 부여한다.
			 뷰 컨트롤러의 목적을 위해 다음 두가지 샘플을 살펴보자. 
			 첫번째 뷰의 자식 아이템에서 리스너를 사용하느 기본적 사용이다.
			 
			 ex) 
			 	 Ext.define('Study.view.foo.Foo',{
			 	 	extend : 'Ext.panel.Panel',
			 	 	xtype : 'foo',
			 	 	controller : 'foo',
			 	 	items : [{
			 	 		xtype : 'textfield',
			 	 		fieldLabel : 'Bar',
			 	 		listeners: {
			 	 			change : 'onBarChange'
			 	 		}
			 	 	}]
			 	 });
			 	 
			 	 Ext.define('Study.view.foo.FooController',{
			 	 	extend : 'Ext.app.ViewController',
			 	 	alias : 'controller.foo',
			 	 	onBarChange : function(){
			 	 	
			 	 	}
			 	 });
				# 위 예제 코드에서 리스너는 "scope"를 특정하지 않는 "onBarChange"라는 이름의 이벤트 핸들러를 보여주고 있다.
				 내부적으로 이벤트 시스템은 Bar textfield의 기본 범위를 해당 뷰 컨트롤러 자체로 해석한다.
				# 예전부터 리스너 설정은 컴포넌트 생정자에 의해 사용되는 것으로 예약되는 것으로 예약되어 있었기 때문에,
				 어떻게 해서 뷰가 자체적인 이벤트를 리스닝 할 수 있는지 또는 자체적인 base 클래스에 의한 이벤트를 알아챌 수 있는지 궁금할 수 있을 것이다. 
				 해답은 명시적 범위롤 사용하는 것에 있다.   
				 
				 ex)
				 	 Ext.define('Study.view.foo.Foo',{
				 	 	extend : 'Ext.panel.Panel',
				 	 	xtype : 'foo',
				 	 	controller : 'foo',
				 	 	listeners : {
				 	 		collapse : 'onCollapse',
				 	 		scope : 'controller'
				 	 	},
				 	 	items: [{
				 	 	
				 	 	}]
				 	 });
			 	 # 위에서는 Bar 뷰는 Foo의 인스턴스를 자신의 한 아이템으로 생성했다. 
			 	  나아가 Foo뷰에서 그랬던 것처럼 접기(collapse) 이벤트 리스닝을 하고 있다.
			 	  이전 버전의 Ext Js와 센처 터지에서는 이러한 선언은 허용되지 않았었다. 
			 	  Ext JS 5에 이르러 지난 버전의 희망사항 중 하나가 개선된 것이다. 
			 	  Foo 뷰에 의해 선언된 리스너는 Foo의 뷰 컨트롤러에서 처리할 것이고, Bar뷰에서 발생한 이벤트는 Bar의 뷰 컨트롤러에서 담당하게 될 것이다.
			 	  
	 	  2) 레퍼런스
	 	  	: 컨트롤러 로직을 작성할 때 보통 가장 애매한 것 중에 하나가 특정 처리를 완료하기 위해 필요한 컴포넌트를 찾아내는 것이다. 
	 	  	 예를 들면 다음과 같다.
	 	  	
	 	  	ex)
	 	  		Ext.define('Study.view.foo.Foo',{
	 	  			extend : 'Ext.panel.Panel',
	 	  			xtype : 'foo',
	 	  			controller : 'foo',
	 	  			tbar: [{
	 	  				xtype : 'button',
	 	  				text : 'Add',
	 	  				handler : 'onAdd'
	 	  			}],
	 	  			items : [{
	 	  				xtype : 'grid'
	 	  			}]
	 	  		});
	 	  		
	 	  		Ext.define('',{
	 	  			extend : 'Ext.app.ViewController',
	 	  			alias : 'controller.foo',
	 	  			onAdd : function(){
	 	  				
	 	  			}
	 	  		});
		 	# 어떻게 그리드 컴포넌트를 찾아낼 수 있을까? Ext JS 4에서는 "refs" 설정을 사용하거나, 컴포넌트를 찾기 위한 다른 방법을 사용할 수 있었다. 
		 	어떤 방법이든 그리드 컴포넌트를 고유하게 식별할 수 있고, 인식 가능한 어떤 속성을 부여하도록 요구한다.
		 	[참고 : 예전의 기법은 "id"설정과 Ext.getCmp를 이용하거나 "itemId" 설정과 "refs" 또는 다른 컴포넌트 쿼리 메서드를 이용하기도 했다.
		 		  "id"에 의한 방법의 장점은 빠른 탐색이 가능하지만 전체 어플리케이션과 DOM에서 유일한 식별자여야만 한다는 제약이 있으며, 이것은 종종 실현 가능하지 않을 때가 많다.
		 		  "itemId"를 사용하고 컴포넌트 쿼리를 활용방법은 좀 더 유연하지만 원하는 컴포넌트를 위한 탐색이 필요하다. 
		 	] 
		 	# Ext JS 5의 새로운 레퍼런스 설정은 그리드에 "reference"설정을 추가하고 이를 얻기 위해서는 "lookupReference" 메서드를 사용하는 것으로 끝난다.
		 	
		 	ex)
		 		Ext.define('Study.view.foo.Foo',{
		 			extend : 'Ext.panel.Panel',
		 			xtype : 'foo',
		 			controller : 'foo',
		 			tbar : [{
		 				xtype : 'button',
		 				text : 'Add',
		 				handler : 'onAdd'
		 			}],
		 			items : [{
		 				xtype : 'grid',
		 				reference : 'fooGrid'
		 			}]
		 		});
		 		
		 		Ext.define('Study.view.foo.FooController',{]
		 			extend : 'Ext.app.ViewController',
		 			alias : 'controller.foo',
		 			onAdd : function(){
		 				var grid = this.lookupReference('fooGrid');
		 			}
		 		});
			# 이것은 "fooGrid"의 itemId를 할당하고 난 후 "this.down('#fooGrid')"를 수행하는 것과 유사하다.
			 차이점은 잘 드러나지 않지만, 분명히 매우 다르다. 
			 첫번째로 래퍼런스 설정은 컴포넌트의 이를 소유하는 뷰를 스스로 등록하도록 인도한다.
			 두번째로 lookupReference메서드는 레퍼선스 갱신이 필요한 지 알기 위해 캐시를 찾아본다.
			 만약	 모든 것이 좋다면, 이 메서드는 캐시로부터 래퍼런스를 리턴한다. 이 과정을 설명하기 위한 pseudo코드는 아래와 같다.
			 
			 ex)
			 	lookupReference : (reference){
			 		var cache : this.reference;
			 		if(!cache){
			 			Ext.fixRefernce
			 		}
			 	}
		 	# 다른 말로 표현하면, 컨테이너에 아이템을 추가 또는 제거에 따른 링크 손상이 없고, 탐색이 필요 없다는 것이다.
		 	 아래에서 자세히 살피겠지만, 이런 방식의 접근이 주는 다른 효율성 측면의 향상이 있다.
		 	 
	 	 3) 추상화
	 	 	: Ext JS 4 MVC에서 선택자의 사용한 구현은 매우 유연하게 사용되었지만 동시에 명백한 위험도 존재했다.
	 	 	 선택자의 실상은 컴포넌트 게층구조의 모든 레벨에 걸쳐 모든 것을 다 검사한다는 것으로 매우 강력하면서도 실수하기 쉽다는 것이다.
			 예를 들어, 컨트롤러는 개별적인 실행환경에서 100% 독립적으로 주어진 일을 처리한다. 
			 그러나 선택자의 경우 새로운 뷰가 존재할 경우 원하지 않는 일치가 발생할 수 있다.
			 
			  이렇나 문제는 확신한 연습을 통해 관리 가능하지만, 리스너와 레퍼런스를 뷰 컨트롤러와 함게 사용하게 되면 문제는 간단히 풀리기 어렵게 된다. 
			 왜냐하면 리스너와 레퍼런스 설정은 오직 자체적인 뷰 컨트롤러에 의해 소유되어 연결되기 때문이다. 
			 뷰는 고유한 레퍼런스 값을 자유롭게 선택할 수 있으며, 그러한 이름들은 뷰 생성사에게 노출되지 않는다.
			 
			  유사하게, 리스너는 그들을 소유한 뷰 컨트롤러에 의해 처리되고, 잘못된 선택자아 의한 다른 컨트롤러에게 처리할 수 없도록 되어 있다.
			 리스너가 적합한 선택자에게 공개되어 있는 것은 선택자 기반의 접근에 요구되는 두 메커니즘이 서로 잘 작동하기 때문이라고 할 수 있다.
			 
			 모델의 완성을 위해 뷰는 이벤트를 생성해야 한다. 생성된 이벤트는 뷰가 소유한 뷰 컨트롤러에 의해 처리될 것이다. 
			 아래는 뷰 컨트롤러의 헬퍼 메서드 fireViewEvnet로서 다음과 같다.
			 
			 ex)
			 	Ext.define('Study.view.foo.FooController',{
			 		extend : 'Ext.app.ViewController',
			 		alias : 'controller.foo',
			 		onAdd : function(){
			 			var record = new Study.model.Thing();
			 			var grid = this.lookupReference('fooGrid');
			 			grid.store.add(record);
			 			this.fireViewEvent('addrecord',this,record);
			 		}
			 	}); 	 	
			# 이제 뷰에서 표준으로 사용하느 방식에 따라 리스너를 추가하면 된다.
			
			ex)
				Ext.define('Study.view.bar.Bar',{
					extend : 'Ext.panel.Panel',
					xtype : 'bar',
					controller : 'bar',
					items: [{
						xtype : 'foo',
						listeners : {
							collapse : 'onCollapse',
							addrecord : 'onAddRecord'
						}
					}]
				});
			
		4) 리스너와 이벤트 도메인
		
			: Ext JS 4에서 MVC 이벤트 디스패처는 이벤트 도메인의 도입과 함께 사용되었다.
			 이벤트 도메인은 이벤트가 발사되면 이를 가로채서 선택자 매칭에 의해 제어되는 컨트롤러에게 이벤트를 배포한다. 
			 "컴포넌트" 이벤트 도메인은 다른 도메인이 제한된 선택자를 갖기 때문에 전체 컴포넌트 쿼리 선택자를 갖는다.
			 
			  Est JS 5에서는 각각의 뷰 컨트롤러는 "뷰" 이벤트 도메인이라고 불리우는 새로운 타입의 이벤트 도메인의 인스턴스를 생성한다.
			 이 이벤트 도메인은 뷰 컨트롤러가 속한 뷰에 명시적으로 범위를 한정하여 표준으로 "listen"과 "control" 메서드를 사용할 수 있도록 허용한다. 
			 또한 자체적으로 뷰를 매칭하기 위한 특별한 선택자르 추가한다.
			 
			 ex) 
			 	Ext.define('',{
			 		extend : 'Ext.app.ViewController',
			 		alias : 'controller.foo',
			 		control : {
			 			'#' : {
			 				collapse : 'onCollapse'
			 			},
			 			button : {
			 				click : 'onAnyButtonClick'
			 			}
			 		}
			 	});  		 	
			# 위 코드에서는 리스너와 선택자의 중요한 차이점을 볼 수 있다. 
			 "button"선택자는 지금의 뷰 혹은 지금 뷰를 상혹하는 자식 뷰에 속한 아무 버튼을 찾을 것이다.
			 버튼 선택자의 탐색은 상속 계층에 상관하지 않고 심지어 버튼이 4번째 상속된 뷰에 있을 경우라도 해당된다.
			 다른 표현으로 하자면, 선택자 기반의 핸들러는 추상화 범위를 상관하지 않는다는 것이다. 
			 이렇나 속성은 Ext.app.Controller 속성과 함께 일관되며, 제한도니 상황에서 때론 유용하게 사용될 수 있다.
			 
			 마지막으로, 이러한 이벤트 도메인들은 중첩적으로 구성되며 뷰 계층에서 발생시키는 이벤트에 대해 효과적으로 대응한다. 
			 이벤트가 발생되면 처음엔 모든 표준 리스너에게 전달된 후 소유하고 있는 뷰 컨트롤러에게 전달되며, 계층구조에 따라 부모 뷰컨트롤러에게 순차적으로 전달된다.
			 최종적으로 이벤트는 Ext.app.Controller를 파생한 컨트롤러에 의해 처리되는 표준 "컴포넌트" 이벤트 도메인으로 전달된다.		 	
				 	
		5) 생명주기(Lifecycle)
			: 대형 어플리케이션 개발 시 일반적인 기법은 필요한 상황이 오면 동적으로 컨트롤러를 생성하는 것이다. 
			 이러한 동적 생성기법은 어플리케이션 로딩 시간을 줄여주고, 필요한 모든 컨트롤러를 활성화 하지 않음으로서 실행 시의 성능을 개선하는 효과가 있다.
			 Ext JS 5 이전 버전에서는 한번 컨트롤러가 생성되면 생성된 컨트롤러는 어플리케이션 종료 시까지 계속 살아있게 되는 단점이 있었다.
			 생성된 컨트롤러를 소멸 시키는 것이 불가능 했기 때문에 점유하고 있는 리소스 회수도 불가능 했다. 
			 또한 이전 버전의 컨트롤러는 비현실적으로 연결된 뷰를 아예 갖지 않거나 제한 없는 수로 연결이 가능하기도 했었다.
			 
			  뷰 컨트롤러의 개념이 도입된 Ext JS 5에서는 컴포넌트 생명주기의 가장 처음에 뷰 컨트롤러를 생성하고, 뷰의 전체 생명주기로 그 기간을 한정한다.
			 뷰가 소멸될 때, 뷰 컨트롤러 역시 소멸된다. 이 의미는 뷰 컨트롤러에 대해 연결된 뷰가 전혀 없는지, 혹은 아주 많은지 강제로 그 상태를 관리할 필요가 없다는 것을 뜻한다.
			 
			  이러한 1대1 관계는 레퍼런스 추적이 간소화 되었으며, 소멸된 컴포넌트에 의한 누수가 이제 더 이상 없다는 것을 의미한다. 
			  뷰 컨트롤러의 생명주기 동안 메서드 구현 시 참고할 중요 지점은 다믕과 같다. 
			  		 	
				1) beforeInit - 이 메서드는 뷰의 initComponent 메서드가 호출되기 전에 뷰 조작을 수행하기 원할 때 오버라이드 할 수 있다. 
							   이 메서드는 컴포넌트 생성자가 initConfig 메서드 호출을 수행하는 동안 컨트롤러가 생성되면 즉시 호출된다.
							   
			 	2) init - initCompoonent가 뷰에서 호출되면 조금 있다가 실행된다. 
			 	   		 뷰가 초기화된 후 컨트롤러 초기화를 수행하는 단계
			 	   		 
	 	   		3) initViewModel - 뷰의 뷰 모델이 정의되어 있을 경우, 뷰 모델이 생성되면 호출된다.
	 	   		4) destory - callParent 호출을 통해 인스턴스를 제거하고 리소스를 반환한다. 	
				 	
3. 뷰 모델과 데이터 바인딩
	- 데이터 바인딩과 뷰 모델은 Ext Js 5에서 도입된 강력한 기능으로, 둘은 함께 사용되어 좀 더 적은 코드와 좀 더 선언적인 스타일로 개발을 가능하게 한다.
	
	- 뷰 모델은 데이터 객체를 관리하느 클래스라고 할 수 있다. 뷰 모델은 데이터 바인딩과 데이터 변경을 알려주는 역할을 담당한다. 뷰 컨트롤러와 유사하게 레퍼런스에 의해 뷰에 귀속된다.
	 뷰 모델이 뷰와 연결되기 때문에 컴포넌트 게층구조에서 상위의 부모 뷰 모델과 연결되는 것 역시 가능하다. 따라서 부모 뷰 모델의 데이터를 자식 뷰에서 간단하게 상속 받을수 있다.
	  
	- 컴포넌트는 새로운 "bind" 설정을 갖게 되어 뷰 모델로부터 받는 데이터를 자체적인 다른 설정과 연동하는 것이 가능해졋다. 
	 바인드를 사용함으서, 적절한 컴포넌트 설정은 연동된 값이 변경될 때 호출 할 수 있는 자체적인 setter메서드를 사용할 수 있게 되어 더 이상 사용자 이벤트 핸들러는 필요 없어졌다.  
	 
3-1. 컴포넌트 바인딩
	: 뷰모델과 바인딩을 이해하는 가장 최선의 방법은 컴포넌트에 바인딩을 사용하는 다양한 예를 살펴보는 방법 일 것이다. 컴포넌트가 데이터 바인딩의 가장 큰 수요자이기 때문이기도 하고
	 컴포넌트가 대부분의 Ext JS 개발자에게 친숙한 항목이기 때문이기도 하다. 바인디을 구현하기 전에 레퍼런스로 지정하고 나중에 정의할 뷰 모델이 우선 필요하다. 
	
	1) 바인딩과 설정
		- 컴포넌트 바인딩은 Ext.app.ViewModel의 데이터를 컴포넌트 설정 프로퍼티에 연결하는 절차라고 할 수 있다. Setter메서드를 갖는 한 모든 컴포넌트 설정은 바인딩 대상이 될 수 있다.
		 예를 들어, Ext.panel.Panel의 setTitle() 메서드가 있기 때문에 title설정에 이를 바인딩 할 수 있다.
		
		- 아래 예에서는 뷰모델의 데이터를 기반으로 패널의 width를 설정하는 것을 살펴보기로 하자. Ext.panel.Panel에서 사용할 수 있는 seteWidth()를 활용해 데이터를 바인딩할 것이다.
		
		ex)
			Ext.create('Ext.panel.Panel',{
				title : 'Simple.Form',
				viewModel : {
					type : 'test'
				},
				bind : {
					html : '<p>Hello {name}'
					width : '{someWidth}'
				}
			});
		# 데이터를 바인딩하기 위한 문법은 위에서 볼 수 있는 것과 같이 Ext.Template에서 사용하는 것과 매우 유사하다. {}안에 텍스트를 집어넣고 ''로 감싸면 된다.
		 Ext.Template와 같은 방식으로 formatter 역시 사용할 수 있다. Ext.Tempalate 과 다른 점이라면 '{someWidth}'의 예와 같이 ""가 아닌 ''를 사용한다는 점이다.
		 
		# "name"과 "someWidth"가 어떻게 변환되는지는 나중에 살펴볼 예정이다. 위 예제는 컴포넌트에서 어떻게 데이터가 바인딩되어 사용되는지 알 수 있다. 
	
	2) 불린(Boolean) 설정의 바인딩
		- 아마도 데이터 바인딩을 하고자 하는 많은 설정 값 들이 visible(또는 hidden), disable, checked, pressed와 같은 형식의 불린 값을 갖을 것이다. 
		 바인드 템플릿은 "인라인"으로 불린 논리를 지원한다. 다른 형태의 바인드 탬플릿과 달리 불린 값의 처리는 특별한 프로비전을 제공하면 된다.
		 
		 ex) 
		 	Ext.create('',{
		 		title : 'Simple Form',
		 		viewModel : {
		 			type : 'test'
		 		},
		 		items : [{
					type : 'button',
					bind : {
						hidden: '{!name}'
					}		 			
		 		}]
		 	});
	 	# 위 코드에서는 또한 ''(싱클 토큰) 템플릿 안의 값이 어떻게 문자열로 변경되지 않는지를 보여준다. "name"이 문자열 값이지만 "!"을 사용하여 이를 부정하여 불린 값으로 전호나한 다음 버튼의
	 	 setHidden 메서드로 이를 전달한다.   		

	3) 바인딩과 우선순위
		- 바인드 설정 프로퍼티는 언제나 설정에 의해 정적으로 지정된 값을 데이터 바인딩과 결과 값으로 덮어 쓰게 된다. 다시 말해 정적 설정 값보다 바인드 설정에 의한 값이 우선 순위를 갖는다는 의미이다.
		 그러나 데이터가 패치되는 시간만큼 지연은 있을 수 있다.
		 
		 ex)
		 	Ext.create('Ext.panel.Panel',{
		 		title : 'Simple Form',
		 		viewModel : {
		 			type : 'test',
		 		},
		 		bind : {
		 			title : 'Hello {name}'
		 		}
		 	});
		 # "name"에 해당하는 바인딩 데이터가 도착하면, "Simple Form"이라는 title은 교체될 것이다.
		 
	4) 바인딩과 자식 컴포넌트
		- 바인딩의 가장 유용한 부문 중의 하나는 뷰 모델이 있는 컴포넌트의 모든 자식에 대해 컨테이너 데이터 접근이 가능하다는 점이다.
		 아래 예에서 form의 자식 아이템이 아이템이 속한 컨테이너 뷰 모델로부터 데이터를 얻는 것을 볼 수 있다.
		 
		 ex)
		 	Ext.create('Ext.panel.Panel',{
		 		title : 'Simple Form',
		 		viewModel : {
		 			type : 'test'
		 		},
		 		layout : 'form',
		 		defaultType : 'textfield',
		 		items : [{
		 			fieldLabel : 'First Name',
		 			bind : '{firstName}'
		 		},{
		 			fieldLabel : 'Last Name,
		 			bind : '{lastName}'
		 		}]
		 	});
	
	5) Two Way 바인딩
		- 바인딩 설정은 two-way 데이터 바인딩을 지원하여 뷰와 모델 간의 실시간 동기화를 가능하게 한다. 뷰에서 변경된 데이터는 모두 자동으로 모델에 반영된다. 
		 이러한 자동적인 업데이트를 통해 같은 데이터를 공유하는 다른 컴폰넌트들이 동일한 데이터를 사용할 수 있도록 하는 것이다.
		 
		- 위 예제에서 "firstName"와 "lastName" 프로퍼티는 textfield에 바인딩 되어 있기 때문에 사용자 입력에 의해 수정된 데이터는 다시 뷰 모델로 되돌아가서 기록되는 것이다.
		 어떻게 이러한 모든 연결들이 구성되는지 알아보기 위해 뷰 모델을 정의하고 예제 코드를 완성해보자
		 
		 ex)
		 	Ext.define('TestViewModel',{
				extend : 'Ext.app.ViewModel',
				alias : 'viewmodel.test',
				data : {
					firstName : 'John',
					lastName : 'Doe'
				},
				formulas : {
					name : function(get){
						var fn = get('firstName'), ln = get('lastName');
						return (fn && ln) ? (fn + ' ' + ln) : (fn || ln || '');
					}
				}
		 	});
	
			Ext.define('TestView',{
				extend : 'Ext.panel.Panel',
				layout : 'form',
				viewModel : {
					type : 'test'
				},
				bind : {
					title : 'Hello {name}'
				},
				defaultType : 'textfield',
				item : [{
					fieldLabel : 'First Name',
					bind : '{firstName}'
				},{
					fieldLabel : 'Last Name',
					bind : '{lastName}'	
				},{
					type : 'button',
					text : 'Submit',
					bind : {
						hidden : '{!name}'
					}
				}]
			});
			
			Ext.define(function(){
				Ext.create('TestView',{
					renderTo : Ext.getBody(),
					width : 400
				})
			});
		# 위 패널이 화면에 그려질 때, textfield의 값이 패널 title에 반영되면서 동시에 Submit 버튼이 hidden으로 변경되는 것을 볼 수 있을 것이다.
			
	6) 바인딩과 컴포넌트 상태
		- 가끔은 컴포넌트의 상태는, 예를 들어 checkbox 또는 그리드에서 선택된 레코드의 "checked", 다른 컴포넌트에 의해 주목 될 때가 있다. 컴포넌트가 식별을 위해 "reference"속성이 지정되면서 뷰 모델에 
		 몇가지 핵심 프로퍼티를 전달한다.
		 
		- 이번 예제에서 checkbox의 checked 상태에 연동하여 "Admin Key" textfield를 비활성하는 설정을 지정했다.
		 이 결과로 checkbox가 checked 상태가 될 때까지 textfield는 비활성화 상태를 유지할 것이다. 이러한 특징들은 아래와 같이 동적인 폼을 구현하기 위해 적절히 사용 될 수 있을 것이다.
		 
		 ex)
		 	Ext.create('Ext.panel.Panel',{
		 		title : 'Sign Up Form',
		 		viewModel : {
		 			type : 'test'
		 		},
		 		items : [{
		 			xtype : 'checkbox',
		 			boxLabel : 'Is Admin',
		 			reference : 'isAdmin'
		 		},{
		 			xtype : 'textfield',
		 			fieldLabel : 'Admin Key',
		 			bind ; {
		 				disabled : '{!isAdmin.checked}'
		 			}
		 		}]
		 	});  
	
	7) 바인드 설명자(Bind Descriptors)
		- 지금까지 3가지 기본 형태의 바인드 설명자를 경험했다.
			# {firstName} - 뷰 모델의 어떤 값에 대한 "direct bind", 이 값은 unmodified 상태로 전달되어 데이터 타입에 상관없이 어떤 값이든지 수신가능하다.
			# Hello {name} - "bind template"은 항상 다양한 표현식에 의해 삽입된 문자열 값을 생산한다. 바인드 템플릿은 또한 Ext.Template과 같이 formatter를 사용할 수 있다. 에를 들면 'Hello{name:capitalize}' 이런 식이다.
			# {!isAdmin.checked} - direct bind의 부정형으로 불린 설정 프로퍼티를 바인딩할 때 사용
		
		- 위의 기본 세가지 형태말고 몇가지 특별한 형태의 바인드 설명자를 사용할 수도 있다.
		
		7-1) Multi-Bind
		: 만약 객체 또는 배열이 바인드 설명자로 주어진다면, 뷰 모델은 객체 또는 같은 형태의 배열을 생성할 것이지만, 다양한 프로퍼티들은 바인딩 결과 값으로 대체될 것이다. 예를 들어
		
		ex)
			Ext.create('Ext.Component',{
				bind : {
					data : {
						fame : '{firstName}',
						lname : '{lastName}'
					}
				}
			});
		# 위와 같은 코드는 컴포넌트의 "data"설정을 두개의 프로퍼티를 뷰 모델로부터 얻는 객체로 설정한 것이다.
		
		7-2) Record Bind
		: 예를 들어 42를 id로 갖는 "User"와 같은 형태의 특정한 레코드가 요구될 때, "reference"프로퍼티를 갖는 객체로 뱌인드 설명자를 지정할 수 있다. 예를 들어,
		
		ex)
			Ext.create('',{
				bind : {
					data : {
						reference : 'User',
						id : 42
					}
				}
			});
		# 이와 같은 경우, 컴포넌트 tpl은 컴포넌트가 로딩될 때 한번에 user레코드를 수신한다. 이 방법을 사용하기 위해서는 Ext.data.Session을 사용해야 한다.
		
		7-3) Association Bind
		: Record bind와 유사하게 바인드도 결합을 갖을 수 있다.
		
		ex)
			Ext.create('',{
				bind : {
					data : {
						reference : "User",
						id : 42,
						association : 'address'
					}
				}
			});
		# 이와 같은 경우, 컴포넌트 tpl은 로딩될 때 User의 "address" 레코드를 수신할 것이다. 마찬가지로 Ext.data.Session의 사용이 요구된다.
		
		7-4) 바인드 옵션 	  
		: 바인드 설명자의 마지막 형식은 바인딩 옵션을 설명 해야 할 필요가 있을 때 사용된다. 다음 예는 어떻게 바인드를 통해 단 하나의 값을 수신하고 수신한 이후 연결을 끊는지를 보여준다.
		
		ex)
			Ext.create('Ext.Component',{
				bind : {
					data : {
						bindTo : '{name}',
						single : true
					}
				}
			})
		# "bindTo" 프로퍼티는 바인드 설몀자 객체에서 두번째로 예약된 이름으로 (첫번째는 "reference"), 이 옵션이 설정되면 "bindTo"로 지정된 값이 실제 바인드 설명자로 대체되며, 다른 프로퍼티들은 
		 설정 옵션에서 지정된 바에 따르게 된다.
		 
		# 현재 지원되는 다른 바인드 옵션은 "deep"이다. 이 옵션은 객체에 바인딩 할 때 객체의 어떤 프로퍼티가 변경될 때 단순히 래퍼런스로만 갖고 있는 것이 아니라 변경에 대한 알림까지 바인딩 하는 것이다.
		 이 설정은 데이터로 객체를 수신하는 "data" 설정에서 지정한다.
		 
		ex)
			Ext.create('',{
				bind : {
					data : {
						bindTo : '{someObject}',
						deep : true
					}
				}
			});  
		
3-2. 뷰 모델 생성				 	
	: 지금까지 컴포넌트가 어떻게 뷰 모델을 사용하는지 잘 살펴보았다. 이제 뷰 모델과 그것이 제안하는 장점이 무엇이 있는지 살펴볼 차례다
	  앞서 살펴본 바와 같이 뷰 모델은 기본적인 데이터 객체의 관리자라고 할 수 있다. 뷰 모델은 객체의 컨텐츠라고 할 수 있으며 바이드 선언에 의해 소비된다.
	 부모 뷰 모델로부터의 데이터 상속은 자바 스크립트 프로토타입 체인에 의해 자식 뷰 모델로 진행된다. 
	 이 사항에 대한 자세한 참고는 View Model internals 지침에서 찾을 수 있을 것이다.
	  간략하게는 자식 뷰 모델의 데이터 객체는 프로토타입으로써의 부모 뷰 모델의 데이터 객체로 정의된다. 
	  
	1) Formulas
	- 데이터를 유지하고 바인딩을 통해 제공하는 것에 덧붙여, 뷰 모델은 "formulas"를 통해 다른 데이터로부터 데이터를 계산(조작) 해내는 쉬운 방법을 제공한다. 
	 Formulas는 뷰 모델에서 데이터 독립성을 추상화하고 뷰의 구조를 자유롭게 선언하도록 지원한다.
	- 다른 의미로 데이터는 뷰 모델의 데이터에서 변경되지 않지만, formulas를 활용해 다른 식으로 변형되어 화면에 나타내어 질 수 있는 것이다.
	 이 점은 전통적인 데이터 모델의 필드에서 conver설정이 동작하는 방식과 유사하다. 
	 앞선 예제에서 간단한 "name" formula의 예를 보았었다. 
	 "name" formula는 뷰 모델에서 서로 다른 두 값 "forstName"과 "lastName"을 조합하는 것이다.
	- formula는 또한 다른 formula의 결과값을 사용할 수도 있다. 예를 들면 다음과 같다
	
	ex)
		Ext.define('TesViewModel2',{
			extend : 'Ext.app.ViewModel',
			alias : 'viewmodel.test2',
			formulas : {
				x2y : function(get){
					return get('x2')*get('y');
				},
				x2 : function(get){
					return get('x')*2;
				}
			}
		});
				 	
	# "x2" formula는 "x" 프로퍼티를 "x * 2"로 처리하여 "x2"로 정의하기 위해 사용했다. "x2y" formula는 "x2"와 "y"를 둘다 사용했다.
	 이 정의의 의미는 만약 "x"가 벼경되면 "x2"가 재계산되어 "x2y"가 된다는 의미이다. 그러나 "y"가 변경되면 "x2y"만 재계산 될 것이다.
	 
	2) 명시적 바인딩을 이용한 Formula
	- 위 예제에서 formula의 의존성은 함수의 검사를 통해 확인할 수 있다. 그러나 이것은 항상 좋은 예는 아니다. 바인드의 모든 데이터가 준비되었을 때 간단한 객체를 반환하는 명시적 바인딩 선언을
	 사용하는 방법은 아래와 같이 소개한다.
	 
	 ex) 
	 	Ext.define('TestviewModel2',{
	 		extend : 'Ext.app.ViewModel',
	 		alias : 'viewmodel.test2',
	 		formulas : {
	 			something : {
	 				bind : {
	 					x : '{foo.bar.x}',
	 					y : '{bar.foo.thing.zip.y}'
	 				},
	 				get : function(data){
	 					return data.x + data.y;
	 				}
	 			}
	 		}
	 	});			 	
				 	
	3) Two-way Formulas
	- 값이 설정될 때 two-way 바인딩 개념에 따라 "set"메서드 호출을 이용한 Formula 처리도 가능하다. "this" 포인터가 뷰 모델에 있기 때문에 "set" 메서드를 this.set()으로 호출해서 뷰 모델에 적당한 갓을 설정할 수 있다.
	 아래의 TestViewModel의 수정된 코드는 "name"이 어떻게 two-way formula로서 설정되는지를 설명한다.
	 
	 ex) 
	 	Ext.define('TestViewModel',{
	 		extend : 'Ext.app.ViewModel',
	 		alias : 'viewmodel.test',
	 		formulas : {
	 			name : {
	 				get : function(get){
	 					var fn = get('firstName'), ln = get('lastName');
	 					return (fn && ln) ? (fn + ' ' + ln) : (fn || ln || ' ');
	 				},
	 				set : function(value){
	 					var space = value.indexOf(' ');
	 					    split = (space < 0) ? value.length : space;
 					    this.set({
 					    	firstName : value.substring(0, split),
 					    	...
 					    })
	 				}
	 			}
	 		}
	 	});			 	
				 	
	4) 권고사항
	- 뷰 모델의 formula와 데이터 바인딩과 같은 강력한 기능은 사용하기 나름에 따라 남발하게 될 수도 또는 사용을 지양하게 될 수도 있으며, 나중에 코드를 이해하거나 디버깅이 어려운 어플리케이션을 작성하게 할
	 가능성도 있으며, 성능 저하 또는 메모리 누수의 원인으로 작용할 수도 있다. 이러한 문제를 회피하고 뷰 모델의 적정한 사용을 위해 다음과 같은 기법을 권고한다.
	 
	 : 뷰 모델을 설정할 때 항상 다음과 같은 형식을 준수한다. 이것은 Confir System이 설정 값을 병합하는 방법을 고려하면 매우 중용하다. 아래와 같은 코드 형식에서 "type" 프로퍼티는 병합할 때 그 값이 보전된다.
	 
	 ex)
	 	Ext.define('TestView',{
	 		//...
	 		viewModel : {
	 			type : 'test'
	 		},
	 		//...
	 	});			 	
	# 명확한 이름을 부여한다. 특별히 상속 계층에서 최상위에 위치할 뷰 모델에서는 명확한 이름을 부여해야 한다. 자바 스크립트에서는 문자열 기반의 검색에 의존하기 때문에 이름을 명확하게 부여하는 것은 검색을 쉽게하여 사용서응ㄹ 높일 수 있다.
	 프로퍼티, 클래스 및 변수 이름은 유일하거나 이름에서 그 용도를 충분히 짐작할 수 있도록 네이밍을 하는 것이 중요하다.
	 
	# 객체에 데이터를 중첩하지 말고 필요하면 깊이를 더하라. 뷰 모델에 저장된 여러 개의 최고 수준 객체들은 하나의 객체에 여려개의 서브 객체들이 중첩된 것과 비교해서 더 작은 예약 공간을 소모한다. 나아가 많은 컴포넌트들이 어떤 커다란 컨테이너 객체에
	 의존하는 것과 비교해서 데이터 의존 관계를 파악함에 있어 훨씬 명확하게 하는 효과도 잇다. 객체를 공유하는 이유는 있겠지만, 뷰 모델은 단지 관리된 객체이며 개발자는 이것의 프로퍼티를 이용하는 것이 목적임을 기억하라.
	 
	# 데이터의 깔끔한 관리를 위해 자식 뷰 모델과 필요하다면 컴포넌트를 사용하라. 만약 모든 데이터를 최상위 뷰모델에 몰아 넣어놓고 자식 뷰에서 사용하도록 한다면, 익서이 소멸되어 필요 없어졌을 때에도 계속 데이터는 제거되지 않고 메모리를 점유하고 있을 것이다.
	 대신에 자식 뷰를 위한 뷰 모델을 생성하고, 데이터를 거기로 보내라
	 
	# *진짜 필요하지 않으면 자식 뷰 모델을 만들지 마라. 각 뷰 모델 인스턴스는 생성할 때 시간과 메모리를 소모한다. 만약 자식 뷰가 자체적으로 유일한 데이터를 필요로 하지 않는다면, 컨테이너로부터 뷰 모델을 상속받아 데이터를 사용할 수 있을 것이다.
	 이전 권고사항 항목과 대비하여, 부모 뷰 모델을 많이 건드려야 하고 메모리 점유 측면에서 효율성이 있을 때에만 자식 뷰 모델을 생성하는 것이 좋다.
	 
	# 바인딩의 반복보다 Formula를 사용하라. 만약 formula가 어떻게 여러 개의 바인딩 결과를 조합할 수 있는지 안다면 formula를 사용함으로써 많은 곳에서 직접 같은 값을 여러번 사용하는 것과 비교해서 얼마나 의존성을 줄일 수 있는지 알 수 있을 것이다.
	 예를 들어, 뷰 모델에서 3개의 의존성을 갖는 하나의 formula가 있고 4명의 사용자가 있다면 3+4=7, 즉 7개의 의존성이 발생하게 된다. 만약 4명의 사용자가 각각의 3개의 의존성이 있는 동작을 수행했다면 4*3=12개의 의존성이 발생하게 된다.
	 더 작은 의존성은 작은 메모리를 사용하고 더 짧은 프로세스 시간을 사용한다.
	 
	# formula를 너무 깊게 연결하지 마라. 코드 간결성 이슈 측면에서 이것은 그렇게 큰 런타임 비용을 유발하지는 않지만, 체인으로 연결된 formula는 데이터와 컴포넌트의 연결을 명확하게 볼 수 없게 하여 무슨 일이 일어나는지 이해하기 어렵게 만든다.
	
	# Two-way formula는 반드시 안정적이게 작성해야 한다. formula "foo"는 "bar"값을 계산한다. "foo"가 값을 set한면 "bar"는 get메서드로부터 formula의 역행에 따라 설정될 것이다. 이 결과는 만약 get메서드가 방금 set한 "foo"의 값과 정확히
	 동일한 값을 산출한다면 안정적이라고 할 수 있다. 만약 그렇지 않다면, 프로세스는 안정점을 찾을 때까지 반복되거나 불명확하게 게속 될 것이다. 
				 	
4. 뷰 모델의 내부구조
	: 지금까지 뷰 모델이 어떤 일을 할 수 있는지 살펴봤으니, 이제부터 숨겨진 내부에서 어떤 일이 발생하는지 한번 알아보기로 하자, 내부 메커니즘에 대한 기초적인 이해는 뷰 모델이 작성된 코드에서 어떤식으로 처리되는지 알게 됨으로해서 나중에 직면하게 될 이슈를
	 분석하는데 도움이 될 것이다.
	  뷰 모델은 두 가지 명확한 업무를 갖는다.
	  
		- 데이터 객체의 변경 관리
		- 데이터가 변경될 때 바인딩 스케줄링 관리
		
4-1. 뷰 모델 데이터와 상속
	: 뷰 모델 클래스는 "데이터" 객체를 관리하고 자바스크립트 프로토타입 체인을 이용해 값을 상속한다. 이를 설명하기 위한 도표는 다음과 같다.		
	
	- Container 1    		 		-> ViewModel 1   -> Data 1
	  	Container
	  		Container
	  			Container
  			Container 2	     		-> ViewModel 2	 -> Data 2
  				Container
  					Container
  						Container
					Container 3		-> ViewModel 3	 -> Data3
						xxx
	# ViewModel 3 -(Parent)-> ViewModel 2 -(Parent)-> ViewModel 1
	  Data 3 -(Prototype)-> Data 2 -(Prototype)-> Data 1 
	
	# 위 도표의 의미는 모든 컴포넌트는 최상위 컨테이너 설정을 통해, "Data 1" 데이터 객체에 저장된 프로퍼티를 읽을 수 있다는 것이다. Container 1에 대해 다음과 같은 경우를 가정하자.
	
	ex)
		viewModel : {
			data : {
				foo: 42
			}
		}   
	# 모든 컴포넌트는 (foo)에 바인딩이 가능하다. 예를 들어 "currentUser"와 같은 중요한 기록을 추적하기 위한 용도로 보통 사용되며 많은 어플리케이션에서 요구되는 기능이다. 
	 사실, 데이터를 사용하기 위해 자바스크립트의 프로토타입 체인을 사용하기 때문에 뷰 모델에서 객체의 게시는 프로퍼티의 변경이 공유하기 적절한 경우라면 종종 좋은 아이디어가 될 수 있다. 
	 왜 그런지 알기 위해서 Container 2의 자식에서 (foo)에 대한 Two-way 바인딩을 한번 생각해보자
	 
	ex)
		{
			xtype : 'textfield',
			bind : '{foo}'
		}   
	# 텍스트 필드는 Data 2를 경유해 Data 1으로부터 프로토타입 체인에 의해 전달된 "42"를 수신할 것이다. 그러나, 이 텍스트 필드 컴포넌트에 의해 수정된 값은 Data 2에 저장된다.
	 이 점은 이런 컴포넌트들이 그들의 뷰 모델 및 데이터 객체와 바인딩되어 있기 때문에 바인드의 양방향 특성에 따라 ViewModel2에서 set을 효과적으로 호출하는 것을 의미하며, 일반적인
	 자바스크립트 객체의 역할을 통해 Data 2에서 foo의 set을 호출하는 것이다. 이러한 동작을 "forking"이라고 하며 뷰에 의해 분리된 값을 초기화 하기 위한 유용한 방법이 될 수 있다. 				 	
				 	
	# "live" 프로퍼티를 상속을 통해 공유하기 위해 root ViewModel에 객체가 저장된다면,
	
	ex)
		viewModel : {
			data : {
				stuff: {
					foo: 42
				}
			}
		}			 	
	# 이제 Two-way 바인딩은 공유된 "stuff" 객체에서 ""foo			 	프로퍼티를 업데이트 할 것이다.
	
	ex)
		{
			xtype : 'textfield',
			bind : '{suff,foo}'
		}
				 	
4-2. 스케줄링과 의존성
	- 데이터 바인딩 속도를 높이는 핵심은 불필요하거나 잉여로 잡힌 연산을 회피하는 것이다. 이것을 관리하기 위해 뷰 모델은 데이터 간의 의존성을 추적한다. 모든 바인딩과 formula는 의존성을 갖게 된다.
	 프레임워크 내부적으로 뷰 모델은 의존성 별로 분할하여 하나의 선형적 스케줄을 생성한다. 따라서 데이터가 변경되면 처리에 필요한 시간만큼 지연이 발생하게 되는 것이다.
	- 따라서, 뷰 모델이나 레코드의 한 필드 값을 변경하고 이를 set 할 때 수 많은 재계산이 즉시 발생할 것을 염려할 필요는 없다. 유사하게, 만약 formula가 7개의 값에 의존성을 갖고, 그 값 모두를 변경해야 할 필요가
	 있다면, formula는 단지 한번의 재게산으로 충분할 것이다. 좀 더 다른 경우를 고려해서, 만약 7개의 formula가 각각 사용되며 각각의 7개의 다른 값에 의존성을 갖는 경우, 모든 49개의 값의 변경은 각 formula별로 한번의 
	 재계산이 필요하게 될 것이다.
	- 이것의 구현을 위해 각 의존성은 뷰 모델이 알고 있어야 하며, 또한 비순환적이어야 한다. 순환적인 의존성 그래프는 에러로 보고한다. 아래 예를 참고하라
	
	ex)
		Ext.define('',{
			extend : 'Ext.app.ViewModel',
			formulas : {
				bar : function(get){
					return get('foo') /2;
				},
				foo : function(get){
					return get('bar') *2;
				}
			}
		});    	
	# 실제 어플리케이션에서 이러한 버그는 사실 위와 같이 명화하게 드러나지 않는 경구가 많지만, 위 코드에서 "foo"와 "bar"는 서로 명확히 의존적 관계이기 때문에 두 메서드가 적절한 값을 찾기 위한 순서 평가는 수행 될 수 없다.
	
4-3. Formula 의존성
	- formula가 명시적 바인드를 사용하면 의존성 역시 명확해진다. formula가 단순한 function 또는 get메서드만 제공하게 되면 뷰 모델은 프로퍼티 레퍼런스를 찾기 위해 function의 text를 파싱(parse)하게 된다. 극단의 편리함과 
	 확신을 위해서는 의존성 목록을 명시적 바인드에서 잊지 않도록 하자. formula parsing에 대한 자세한 사항은 Ext.app.bind.Formula에서 찾을 수 있다.	
	
5. 라우터를 이용한 어플리케이션 제어
	: 일반적인 웹 사이트에서 사용자는 링크를 클릭해서 다른 페이지를 탐색하거나 폼을 입력하거나 하지만, 단일 페이지 어플리케이션의 경우에는 새로운 페이지를 로딩하지 않는다. 대신에 단일 페이지 내부에 포함된 컴포넌트 간의 상호작용에
	 의해 사용자의 입력을 처리하게 된다. 그럴 경우, 만약 사용자의 브라우저 앞으로가기 또는 뒤로 가기 버튼의 사용은 어떻게 허용할 것인가 하는 문제가 남게 된다. 답은 바로 Ext JS 5의 새로운 라우터에 의한 단축 URL 해시 변경이 될 것이다.
	 
5-1. 라우팅은 무슨 목적으로 사용하게 되나?
	: 라우팅은 브라우저 히스토리 스택을 통한 어플리케이션 상태를 추적하기 위해 사용된다. 또한 어플리케이션의 특정 파트에 대한 직접 링크를 허용하기 위한 deep linking을 사용하기 위해서도 사용된다.
	
5-2. 라우팅을 사용하지 말아야 할 경우는?
	: 데이터 또는 세션을 저장할 목적으로 사용되어서는 안되낟. 데이터는 쿠키나 로컬 저장소와 같은 영구적 데이터 소스에 저장되어야 한다. 라우팅은 오직 어플리케이션 상태를 추적하는 도구로만 사용되는 것이 바람직하다.
	
5-3. 해시는 무엇인가?
	: 브라우저는 많은 파트로 구성된 URI를 사용해서 인터넷을 탐색한다. URL에 대한 예를 살펴보자
	 http://www.example.com/apps/users#user/1234
	  상대적으로 친숙해 보일테지만, #user=1234는 아마 인식하지 못했을 것이다. URI의 이 부분은 "해시(hash)"또는 단편적 식별자(fragment identifier)라고 불리우는 것이다. 해시는 어플리케이션에게 현재 페이지의 리로딩 없이 브라우저의
	히스토리 스택을 추가하고 이를 통해 부라우저의 앞으로/뒤로 버튼을 이용한 URI의 탐색을 지원토록 한다. 
	
5-4. 어플리케이션에서 라우팅 구현하기
	
	
	
5-5. 해시 업데이트

5-6. 토큰 기본값(Default Token)

5-7. 파라미터를 갖는 해시

5-8. 해시 파라미터 포매팅(Hash Parameter Formatting)

5-9. 라우터 핸들링

5-10. 일치 항목이 없는 라우팅의 처리

5-11. 단일 해시 값을 이용한 다중 라우팅 사용하기	 
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
		
	