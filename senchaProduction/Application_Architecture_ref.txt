# app.json 수정 시 sencha app build를 실행시켜야 한다. #


1. App 아키텍처 소개
	: Ext JS는 MVC와 MVVM 어플리케이션 아키텍처를 동시에 지원한다. 
	어플리케이션 코드를 논리적으로 분할한다는 관점과 컨셉으로 생각하자면 이 두가지 아키텍처는 분명히 공유하는 점이 많다고 할 수 있다.
	아키텍처 각가의 방법론적 접근은 어플리케이션을 어떤 관점에서 분할 할 것인가에 대한 차이만 있다고 할 수 있다.
	
1-2. MVC 
	: MVC 아키텍처에서 대부분의 클래스는 모델(Model), 뷰(View) 또는 컨트롤러(Controller)에 속한다.
	사용자는 모델에 의해 수집되거나 처리된 데이터를 화면에 그려주는 뷰를 통해 어플리케이션과 상호작용을 수행하게 된다.
	뷰와 사용자와의 상호작용은 컨트롤러에 의해 감시되고, 필요하다면 뷰와 모델을 업데이트 한다.
	
	: 뷰와 모델은 컨트롤러가 중간에 개입하여 업데이트를 중재하기 때문에 직접 서로 간섭하는 일이 드물다.
	일반적으로 컨트롤러는 MVC 어플리케이션에서 대부분의 어플리케이션 로직을 담고 있다. 
	이상적인 경우 뷰는 비즈니스 로직을 거의 갖고 있지 않아야 한다.
	모델은 데이터와 인터페이스가 주요 역할로서 데이터의 변경에 대한 비즈니스 로직을 담당한다.
	
	: 목적 - 어플리케이션에서 각 클래스의 역할을 간결하고 명확하게 정의하는 것이다.
			모든 클래스의 역할이 명확하게 정의되어 있을 경우 대형 어플리케이션 개발환경에서 클래스가 이리저리 꼬이는 모호함을 최소화 할수 있을 것이다.
			이것은 결국 어플리케이션 시험과 유지보수를 쉽게 하고 코드의 재사용성을 높이는 결과를 기대할 수 있다.
	  
1-3. MVVM 
	: MVC와 MVVM의 가장 핵심적인 차이점은 MVVM에서 뷰 모델(ViewModel)이라고 불리는 뷰의 추상화를 지원한다는 점.
	 뷰 모델은 "데이터 바인딩(data binding)"이라는 기수을 사용해서 모델의 데이터와 뷰가 그리는 화면상의 데이터의 변경을 중재한다.
	 
1-4. MVC와 MVVM
	: 어플리케이션에 적합한 아키텍처를 선택할 때 이해를 돕기 위해, 우선 먼저 몇가지 정의를 짚고 갈 필요가 있다.
		1) (M) Model : 어플리케이션에서 사용되는 데이터를 담당
		   			  "Models"라고 불리는 데이터 집합으로 필드와 데이터로 정의된다. 예를 들어 User 모델은 user-name과 password 필드를 갖는다.
		   			  모델은 데이터 패키지를 통해 데이터에 대한 추적을 유지하고 결합(associations)을 통해 다른 모델들과 연결된다.
		   			  모델은 일반적으로 그리드 또는 다른 컴포넌트에 데이터를 제공하기 위한 스토어(Store)와 결합하여 사용되며, 
		   			  또한 validation, conversion 기타 등등 데이터를 취급하다보면 필요할 수 잇는 모든 데이터 로직의 이상적인 장소라고 할 수 있다.
		2) (V) View : 뷰는 화면에 그려지는 비주얼에 관련된 모든 컴포넌트라고 할 수 있다.
					 그리드, 트리, 패널 등 화면에 나타나는 모든 것을 뷰
	    3) (C) Controller : 어플리케이션이 작동하기 위해 필요한 뷰 로직을 관리한다. 
	    				   이에 따라 뷰를 랜더링 하고, 라우팅하거나 모델 인스턴스를 생성하거나 또는 다른 어플리 케이션 로직 일부를 수행토록 한다.
	    4) (VM) ViewModel : 뷰 모델은 뷰로 제공되는 뷰로 제공되는 데이터를 특정하여 관리하기 위한 클래스로서 컴포넌트가 바인딩을 처리하거나 데이터 변경에 따라 업데이트 되도록 하는 역할을 담당한다. 
	    				   이러한 어플리케이션 아키텍처는 코드의 구조화 및 일관성르 부여한다.
	    5) 모든 어플리케이션은 같은 방식으로 동작한다.

1-5. Sencha Cmd
	명령어 : - sencha generate app -ext Study ./app
		   - cd app
		   - sencha app watch 
1-6. 파일 구조 :
	- Ext JS 어플리케이션은 모두 단일화된 폴더 구조를 따른다. 권고하는 파일 배치는 모든 클래스들은 app폴더에 저장하는 것이다. 
	  이 폴더는 어플리케이션 네임스페이스 하위의 모델, 스토어 및 뷰 엘리먼트들을 서브 폴더로 포함하게 된다.
	  뷰, 뷰 컨트롤러, 뷰 모델과 같은 뷰 엘리먼트들은 한 곳에 묶어서 저장한다.
	- 구조
		app
			Application
			>model
				Readme.md
			Readme.md
			>store
				Readme.md
			>view
				>main
					Main.js
					MainController.js
					MainModel.js
			app.js
			app.json
			bootstrap.css
			bootstrap.js
			bootstrap.json
			>build
			build.xml
			>ext
			index.html
			>overrides
			>packages
			Readme.md
			>resources
			>sass	

1-7. 네임스페이스 : 각 클래스의 첫번째 라인은 정렬 순서를 의미한다.
	- (AppName).(foldname).(ClassAndFileName)


1-8. app.js : Application.js 파일 내부에서 생성한 클래스를 app.js에서 인스턴스를 실행
	ex)
		Ext.application({
			name : 'Study',
			
			extend: 'Study.Application',
			
			autoCreateViewport :'Study.view.main.Main'  //-> autoCreateViewport는 Ext JS 5의 새로운기능 :
														//	1. autoCreateViewport에 컨테이너 클래스를 설정하게 되면 뷰 포트로 어떤 클래스드니 사용할 수 있게 된다.
															2. autoCreateViewport 설정은 어플리케이션에게 지정된 뷰를 생성하고 뷰포트 플러그인을 덧붙이도록 지시 => 이렇나 동작은 뷰를 document body에 연결하게 된다.			
		})
		
1-9. Application.js	: - 모든 JS 어플리케이션은 Application 클래스의 인스턴스부터 시작된다. 
					  - 이 클래스는 app.js에 의해 인스턴스가 생성되어 실해오딘다. 아래의 Application.js의 내용은 Sencha Cmd가 자동으로 생성한 것이다.
					  - 아래의 Application.js의 내용은 Sencha Cmd가 자동으로 생성된 것이다.
						ex)
							Ext.define('Study.Application',{ 
								
								extend:'Ext.app.Application',
								name:'Study',
								stores: [
									
								],
								launch: function(){
									
								}
							
							})
						# Application 클래스는 어플리케이션의 Global 설정, 즉 네임스페이스, 공유 스토어 등을 포함한다.

1-10. Views	:- 뷰는 Ext.Component의 서브 클래스인 컴포넌트 그 이상도 그 이하도 아니라고 할 수 있다.
			 - 뷰는 어픞리케이션의 모든 비주얼적 측면을 포함하낟.
			 - "main"폴더의 Main.js파일 
				ex)
					Ext.define('Study.view.main.Main',{
						extend : 'Ext.container.Container',
						xtype : 'app-main',
						controller : 'main',
						viewModel : {
							type : 'main'
						},
						items : [{
							xtype : 'panel',
							bind : {
								title : '{name}'
							},
							region : 'west',
							html : '<ul>...</ul>'
							width : 250,
							split : true,
							sbar : [{
								text : 'Button',
								handler : 'onClickButton'
							}]
						},{
							region : 'center',
							xtype : 'tabpanel',
							items:[{
								title : 'Tab 1',
								html : '<h2>Content ...</h2>'
							}]				
						}]			
					})
				# 뷰에 어플리케이션 로직이 포함되어 있지 않은 점에 주목 
				- 뷰에 관련한 모든 로직은 뷰 컨트롤러에 포함되어야 한다.
				- 예제에서의 뷰는 border 레이아웃을 겆는 컨테이너로서 west와 center 영역을 갖는다.
				 이 영역들은 버튼이 포함도니 툴 바가 위치한 패털과 단일 탭을 갖는 탭 패널을 포함한다. 
				 좀 더 자세한 사항은 Getting Started Guide를 참고
				
				
1-11. 컨트롤러 설정
	- 컨트롤러 설정에서는 뷰를 위한 뷰 모델 지정을 수행한다. 
	- 뷰 컨트롤러가 뷰에 대해 지정되면 이벤트 핸들러와 래퍼런스를 위한 컨테이너로 변화
	- 이러한 사실은 결국 뷰 컨트롤러와 뷰에서 이벤트를 발생시키는 컴포넌트가 1-대-1 관계를 갖는다는 뜻.
	
1-12. 뷰 모델 설정
	- 뷰 모델 설정은 뷰에 대한 뷰 모델을 지정하는 것
	- 뷰 모델은 컴포넌트와 하우 ㅣ뷰에 대한 데이터를 제공하는 역할을 담당한다. 뷰 모델에 담긴 데이터는 컴포넌트와 바인딩 설정에 따라 화면에 전시되거나 편집될 목적으로 사용되는 것이 일반적
	
1-13. 컨트롤러 (Controller)		
	
	ex)
		Ext.define('Study.view.amin.MainController',{
			extend : 'Ext.app.ViewController',
			requires: [
				'Ext.MessageBox'
			],
			alias : 'controller.main',
			onClickButton : function() {
				Ext.Msg.confirm('Confirm', 'Are you sure', 'onConfirm', this);
			},
			onConfirm : function(){
				if(choice === 'yes'){
				}
			}
		})		
		
	- 뷰 모델 설정은 뷰에 대한 뷰 모델을 지정하는 것		
	- 어플리케이션 뷰를 정의한 Main.js로 돌아가서 살펴본다면 tbar button의 핸들러 처리를 위한 함수가 지정되 있음을 알수 있다.
	- 뷰에 속한 컴포넌트의 이벤트 핸들러인 onClickButton함수는 바로 이 컨트롤러에 정의되어 있다.
	- 컨트롤러는 별다른 특별한 설정이 없이 이벤트를 처리할 준비가 되어 있다.
	- 이런 점은 어플리케이션에 매우 쉽게 로직을 추가할 수 있게 된다.
	- onClickButton함수에 필요한 몯느 것ㅇ느 여기에 구현하면 되는데 바로 컨트롤러가 뷰와 1대1관계로 대응하기 때문
	- 목적 
		: 1. "listeners"와 "reference" 설정을 이용한 뷰와 연결
		  2. 연결된 뷰 컨틀롤러를 자동으로 관리함으로서 뷰의 생명주기를 연장, 인스턴스 생성부터 소멸에 이르기까지 Ext.app.ViewwController는 
		  	컴포넌트와 이를 참조하는 뷰 컨트롤러를 묶어주는데 같은 뷰 클래스의 두번째 인스턴스는 자신만의 뷰 컨트롤러 인스턴스를 갖게 된다. 
		  	 이러한 뷰가 소멸될 때 연결된 뷰 컨트롤러 인스턴스 역시 같이 소멸
		  3. 중첩된 뷰의 직관성을 위한 추상화 제공
	
1-14. 뷰 모델
	
	ex) 
		Ext.define('Study.view.main.MainModel',{
			extend : 'Ext.app.ViewModel',
			alias : 'viewmodel.main',
			data: {
				name:'Study'				
			}
		})
	- 뷰 모델은 데이터 객체를 관리하는 클래스이다.
	- 이 클래스는 뷰가 사용할 데이터를 바인딩하고 데이터가 수정되었을 때 알리는 역할을 수행한다.
	- 뷰 컨트롤러와 유사하게 뷰 모델은 래퍼러스를 이용해서 뷰에 연결된다. 뷰 모델이 뷰와 연결되어 있기 때문에 컴포넌트 계층구조의 조상 컴포넌트에 의해 
	 소유된 상위 부모 뷰 모델과 연결되는 것 역시 가능하다. 
	- 이러기에 자식 뷰는 간단하게 부모 뷰 모델의 데이터를 "상속"할 수 있다.
	- Main.js의 뷰 모델 설정을 이용해서 뷰와 뷰 모델의 연결을 생성하였다. 이 연결은 뷰 모델로부터 뷰로 서넝ㄴ적인 형태로서 데이터르 자동으로 설정하기 위한 Setter와 설정을 
	바인딩할 수 있도록 한다. MainModel.js에서 인라인 코딩 되어 있는 데이터를 참고

1-15. Model과 Store
	- 모델과 스토어는 어플리케이션에서 정보의 게이트웨이 역할을 담당한다. 거의 대부분의 데이터는 이 두 클래스에 의 해 "모델화"되거나, 조직화 되거나 또는 보내고 받게 된다.
	- 모델
		1). Ext.data.Model은 어플리케이션에서 지속가능한 모든 형태의 데이터를 대표한다.
		2). 각 모델은 어플리케이션에 대해 "모델"데이터를 제공하기 위한 필드와 함수를 갖는다.
		3). 모델은 가장 일바넉으로 스토어와 결합하여 사용되는데, 스토어는 그리드, 트리 및 차트와 같이 데이터와 함께 사용되는 컴포넌트에 의해 사용된다.
		
			ex)
				Ext.define('Study.model.User',{
					extend:'Ext.data.Model',
					fields:[
						{name:'name', type:'string'},
						{name:'age', type:'int'}
					]
				} 
		# 앞서 네임스페이스 섹션에서 설명한 바와 같이 위 코드는 app/model 폴더에 User.js 파일로 저장되어야 한다.		
	- 필드
		1). Ext.data.Model은 담고 있는 값을 의미하는 레코드 또는 "fields"라고 불리는 속성을 기술한다.
		2). 모델 클래스는 이러한 필드를 "fields"설정을 이용해 정의

1-16. 스토어
	- 스토어는 클라이언트 측면에서 레코드(모델 클래스의 인스턴스)의 캐시라고 할 수 있다.
	- 스토어는 담고 있는 데이터에 대한 정렬(Sorting), 필터링 및 질의(Querying)기능을 제공한다.
		ex)
			Ext.define('Study.store.User',{
				extend : 'Ext.data.Store',
				model : 'Study.model.User',
				data : [
					{firstName : 'Sech', age: '34'},
					{firstName : 'Scott', age: '72'},
					{firstName : 'Gary', age: '19'},
					{firstName : 'Capybara', age: '208'}
				]
			})
		# 위 코드는 app/store 폴더에 User.js 파일로 저장해야 한다. 
		 이렇게 정의된 스코어는 Application.js의 스토어 설정을 통해 스토어를 그롤벌 인스턴스로 설정할 수 있다.
		 -> Application.js의 스토어 설정은 다음과 같다
		 	ex)
		 		stores: [
		 			'User'
		 		],
			# 예제에서 스토어는 직접 인라인 코딩된 데이터를 포함하고 있는데, 대부분의 실제 어플리케이션을 구현할 때는 모델 또는 스토어에서 프록시를 이용해 데이터를 획득하게 된다. 
			 프록시는 데이터 제공자와 어플리케이션간에 데이터 전송을 수행한다.	
	
2. 뷰 컨트롤러 : Ext JS 5는 어플리케이션 아키텍처를 사용함에 있어서 몇가지 주목할만한 발전을 이뤄냈다. MVC 어플리케이션에서의 뷰 컨트로럴와 MVVM 모델과 뷰 모델을 지원하기 시작한 것이다.
			 이들 중 가장 괄목할 만한 점은 이러한 아키텍처의 선택이 상호 배타적이지 않기 때문에 일부 기능을 점진적으로 사용하거나, 혹은 뒤썩어서 사용할 수 도 있다는 점이다.
			 
2-1. 컨트롤러의 개선
	: Ext JS 4에서 컨트롤러는 Ext.app.Controller를 파생한 클래스로 CSS와 유사한 선택자, 즉 컴포넌트 쿼리를 사용하여 컴포넌트를 찾고 해당 컴포넌트의 이벤트를 처리했다.
	 또한 컴포넌트 인스턴스를 선택하거나 넘겨받기 위해 "refs"를 사용했다.
	 
	: 이러한 컨트롤러는 어플리케이션 실행 시 생성되어 어플리케이션이 실행되는 동안 유지되었다. 컨트롤어의 생명주기 동안 뷰에서 발생하는 이번트들이 컨트롤러를 통해 들어오고 나간다.
	 또한 컨컨틀러가 관리하는 뷰는 다중 인스턴스가 될 수도 있었다.
	 
2-2. 뷰 컨트롤러
	: Ext JS 5가 현재 버전의 컨트롤러에 대한 하향 호환성를 유지하면서, 위에서 설명한 문제를 해결하기 위한 방안으로 Ext.app.ViewComtroller라는 새로운 컨트롤러를 소개하고 있다.
		- "listener"와 "reference"설정을 사용하여 뷰와 연결을 간소화 함
		- 연결된 뷰 컨트롤러에 대한 자동 관리를 위한 뷰의 생명주기 연동
		- 관리하는 뷰와 1:1 관계에 기반한 뷰 컨트롤러를 통해 복잡성 제거
		- 중첩된 뷰의 신뢰성 제고를 위한 캡슐화 지원
		- 컴포넌트 선택 및 연결도니 뷰의 게층에 상관없는 이벤트 리스닝 유지
		
		1) 리스너 
			: 리스너 설정은 새롭게 도입된 것으로 Ext JS 5에서 몇가지 새로운 능력을 부여한다.
			 뷰 컨트롤러의 목적을 위해 다음 두가지 샘플을 살펴보자. 
			 첫번째 뷰의 자식 아이템에서 리스너를 사용하느 기본적 사용이다.
			 
			 ex) 
			 	 Ext.define('Study.view.foo.Foo',{
			 	 	extend : 'Ext.panel.Panel',
			 	 	xtype : 'foo',
			 	 	controller : 'foo',
			 	 	items : [{
			 	 		xtype : 'textfield',
			 	 		fieldLabel : 'Bar',
			 	 		listeners: {
			 	 			change : 'onBarChange'
			 	 		}
			 	 	}]
			 	 });
			 	 
			 	 Ext.define('Study.view.foo.FooController',{
			 	 	extend : 'Ext.app.ViewController',
			 	 	alias : 'controller.foo',
			 	 	onBarChange : function(){
			 	 	
			 	 	}
			 	 });
				# 위 예제 코드에서 리스너는 "scope"를 특정하지 않는 "onBarChange"라는 이름의 이벤트 핸들러를 보여주고 있다.
				 내부적으로 이벤트 시스템은 Bar textfield의 기본 범위를 해당 뷰 컨트롤러 자체로 해석한다.
				# 예전부터 리스너 설정은 컴포넌트 생정자에 의해 사용되는 것으로 예약되는 것으로 예약되어 있었기 때문에,
				 어떻게 해서 뷰가 자체적인 이벤트를 리스닝 할 수 있는지 또는 자체적인 base 클래스에 의한 이벤트를 알아챌 수 있는지 궁금할 수 있을 것이다. 
				 해답은 명시적 범위롤 사용하는 것에 있다.   
				 
				 ex)
				 	 Ext.define('Study.view.foo.Foo',{
				 	 	extend : 'Ext.panel.Panel',
				 	 	xtype : 'foo',
				 	 	controller : 'foo',
				 	 	listeners : {
				 	 		collapse : 'onCollapse',
				 	 		scope : 'controller'
				 	 	},
				 	 	items: [{
				 	 	
				 	 	}]
				 	 });
			 	 # 위에서는 Bar 뷰는 Foo의 인스턴스를 자신의 한 아이템으로 생성했다. 
			 	  나아가 Foo뷰에서 그랬던 것처럼 접기(collapse) 이벤트 리스닝을 하고 있다.
			 	  이전 버전의 Ext Js와 센처 터지에서는 이러한 선언은 허용되지 않았었다. 
			 	  Ext JS 5에 이르러 지난 버전의 희망사항 중 하나가 개선된 것이다. 
			 	  Foo 뷰에 의해 선언된 리스너는 Foo의 뷰 컨트롤러에서 처리할 것이고, Bar뷰에서 발생한 이벤트는 Bar의 뷰 컨트롤러에서 담당하게 될 것이다.
			 	  
	 	  2) 레퍼런스
	 	  	: 컨트롤러 로직을 작성할 때 보통 가장 애매한 것 중에 하나가 특정 처리를 완료하기 위해 필요한 컴포넌트를 찾아내는 것이다. 
	 	  	 예를 들면 다음과 같다.
	 	  	
	 	  	ex)
	 	  		Ext.define('Study.view.foo.Foo',{
	 	  			extend : 'Ext.panel.Panel',
	 	  			xtype : 'foo',
	 	  			controller : 'foo',
	 	  			tbar: [{
	 	  				xtype : 'button',
	 	  				text : 'Add',
	 	  				handler : 'onAdd'
	 	  			}],
	 	  			items : [{
	 	  				xtype : 'grid'
	 	  			}]
	 	  		});
	 	  		
	 	  		Ext.define('',{
	 	  			extend : 'Ext.app.ViewController',
	 	  			alias : 'controller.foo',
	 	  			onAdd : function(){
	 	  				
	 	  			}
	 	  		});
		 	# 어떻게 그리드 컴포넌트를 찾아낼 수 있을까? Ext JS 4에서는 "refs" 설정을 사용하거나, 컴포넌트를 찾기 위한 다른 방법을 사용할 수 있었다. 
		 	어떤 방법이든 그리드 컴포넌트를 고유하게 식별할 수 있고, 인식 가능한 어떤 속성을 부여하도록 요구한다.
		 	[참고 : 예전의 기법은 "id"설정과 Ext.getCmp를 이용하거나 "itemId" 설정과 "refs" 또는 다른 컴포넌트 쿼리 메서드를 이용하기도 했다.
		 		  "id"에 의한 방법의 장점은 빠른 탐색이 가능하지만 전체 어플리케이션과 DOM에서 유일한 식별자여야만 한다는 제약이 있으며, 이것은 종종 실현 가능하지 않을 때가 많다.
		 		  "itemId"를 사용하고 컴포넌트 쿼리를 활용방법은 좀 더 유연하지만 원하는 컴포넌트를 위한 탐색이 필요하다. 
		 	] 
		 	# Ext JS 5의 새로운 레퍼런스 설정은 그리드에 "reference"설정을 추가하고 이를 얻기 위해서는 "lookupReference" 메서드를 사용하는 것으로 끝난다.
		 	
		 	ex)
		 		Ext.define('Study.view.foo.Foo',{
		 			extend : 'Ext.panel.Panel',
		 			xtype : 'foo',
		 			controller : 'foo',
		 			tbar : [{
		 				xtype : 'button',
		 				text : 'Add',
		 				handler : 'onAdd'
		 			}],
		 			items : [{
		 				xtype : 'grid',
		 				reference : 'fooGrid'
		 			}]
		 		});
		 		
		 		Ext.define('Study.view.foo.FooController',{]
		 			extend : 'Ext.app.ViewController',
		 			alias : 'controller.foo',
		 			onAdd : function(){
		 				var grid = this.lookupReference('fooGrid');
		 			}
		 		});
			# 이것은 "fooGrid"의 itemId를 할당하고 난 후 "this.down('#fooGrid')"를 수행하는 것과 유사하다.
			 차이점은 잘 드러나지 않지만, 분명히 매우 다르다. 
			 첫번째로 래퍼런스 설정은 컴포넌트의 이를 소유하는 뷰를 스스로 등록하도록 인도한다.
			 두번째로 lookupReference메서드는 레퍼선스 갱신이 필요한 지 알기 위해 캐시를 찾아본다.
			 만약	 모든 것이 좋다면, 이 메서드는 캐시로부터 래퍼런스를 리턴한다. 이 과정을 설명하기 위한 pseudo코드는 아래와 같다.
			 
			 ex)
			 	lookupReference : (reference){
			 		var cache : this.reference;
			 		if(!cache){
			 			Ext.fixRefernce
			 		}
			 	}
		 	# 다른 말로 표현하면, 컨테이너에 아이템을 추가 또는 제거에 따른 링크 손상이 없고, 탐색이 필요 없다는 것이다.
		 	 아래에서 자세히 살피겠지만, 이런 방식의 접근이 주는 다른 효율성 측면의 향상이 있다.
		 	 
	 	 3) 추상화
	 	 	: Ext JS 4 MVC에서 선택자의 사용한 구현은 매우 유연하게 사용되었지만 동시에 명백한 위험도 존재했다.
	 	 	 선택자의 실상은 컴포넌트 게층구조의 모든 레벨에 걸쳐 모든 것을 다 검사한다는 것으로 매우 강력하면서도 실수하기 쉽다는 것이다.
			 예를 들어, 컨트롤러는 개별적인 실행환경에서 100% 독립적으로 주어진 일을 처리한다. 
			 그러나 선택자의 경우 새로운 뷰가 존재할 경우 원하지 않는 일치가 발생할 수 있다.
			 
			  이렇나 문제는 확신한 연습을 통해 관리 가능하지만, 리스너와 레퍼런스를 뷰 컨트롤러와 함게 사용하게 되면 문제는 간단히 풀리기 어렵게 된다. 
			 왜냐하면 리스너와 레퍼런스 설정은 오직 자체적인 뷰 컨트롤러에 의해 소유되어 연결되기 때문이다. 
			 뷰는 고유한 레퍼런스 값을 자유롭게 선택할 수 있으며, 그러한 이름들은 뷰 생성사에게 노출되지 않는다.
			 
			  유사하게, 리스너는 그들을 소유한 뷰 컨트롤러에 의해 처리되고, 잘못된 선택자아 의한 다른 컨트롤러에게 처리할 수 없도록 되어 있다.
			 리스너가 적합한 선택자에게 공개되어 있는 것은 선택자 기반의 접근에 요구되는 두 메커니즘이 서로 잘 작동하기 때문이라고 할 수 있다.
			 
			 모델의 완성을 위해 뷰는 이벤트를 생성해야 한다. 생성된 이벤트는 뷰가 소유한 뷰 컨트롤러에 의해 처리될 것이다. 
			 아래는 뷰 컨트롤러의 헬퍼 메서드 fireViewEvnet로서 다음과 같다.
			 
			 ex)
			 	Ext.define('Study.view.foo.FooController',{
			 		extend : 'Ext.app.ViewController',
			 		alias : 'controller.foo',
			 		onAdd : function(){
			 			var record = new Study.model.Thing();
			 			var grid = this.lookupReference('fooGrid');
			 			grid.store.add(record);
			 			this.fireViewEvent('addrecord',this,record);
			 		}
			 	}); 	 	
			# 이제 뷰에서 표준으로 사용하느 방식에 따라 리스너를 추가하면 된다.
			
			ex)
				Ext.define('Study.view.bar.Bar',{
					extend : 'Ext.panel.Panel',
					xtype : 'bar',
					controller : 'bar',
					items: [{
						xtype : 'foo',
						listeners : {
							collapse : 'onCollapse',
							addrecord : 'onAddRecord'
						}
					}]
				});
			
		4) 리스너와 이벤트 도메인
		
			: Ext JS 4에서 MVC 이벤트 디스패처는 이벤트 도메인의 도입과 함께 사용되었다.
			 이벤트 도메인은 이벤트가 발사되면 이를 가로채서 선택자 매칭에 의해 제어되는 컨트롤러에게 이벤트를 배포한다. 
			 "컴포넌트" 이벤트 도메인은 다른 도메인이 제한된 선택자를 갖기 때문에 전체 컴포넌트 쿼리 선택자를 갖는다.
			 
			  Est JS 5에서는 각각의 뷰 컨트롤러는 "뷰" 이벤트 도메인이라고 불리우는 새로운 타입의 이벤트 도메인의 인스턴스를 생성한다.
			 이 이벤트 도메인은 뷰 컨트롤러가 속한 뷰에 명시적으로 범위를 한정하여 표준으로 "listen"과 "control" 메서드를 사용할 수 있도록 허용한다. 
			 또한 자체적으로 뷰를 매칭하기 위한 특별한 선택자르 추가한다.
			 
			 ex) 
			 	Ext.define('',{
			 		extend : 'Ext.app.ViewController',
			 		alias : 'controller.foo',
			 		control : {
			 			'#' : {
			 				collapse : 'onCollapse'
			 			},
			 			button : {
			 				click : 'onAnyButtonClick'
			 			}
			 		}
			 	});  		 	
			# 위 코드에서는 리스너와 선택자의 중요한 차이점을 볼 수 있다. 
			 "button"선택자는 지금의 뷰 혹은 지금 뷰를 상혹하는 자식 뷰에 속한 아무 버튼을 찾을 것이다.
			 버튼 선택자의 탐색은 상속 계층에 상관하지 않고 심지어 버튼이 4번째 상속된 뷰에 있을 경우라도 해당된다.
			 다른 표현으로 하자면, 선택자 기반의 핸들러는 추상화 범위를 상관하지 않는다는 것이다. 
			 이렇나 속성은 Ext.app.Controller 속성과 함께 일관되며, 제한도니 상황에서 때론 유용하게 사용될 수 있다.
			 
			 마지막으로, 이러한 이벤트 도메인들은 중첩적으로 구성되며 뷰 계층에서 발생시키는 이벤트에 대해 효과적으로 대응한다. 
			 이벤트가 발생되면 처음엔 모든 표준 리스너에게 전달된 후 소유하고 있는 뷰 컨트롤러에게 전달되며, 계층구조에 따라 부모 뷰컨트롤러에게 순차적으로 전달된다.
			 최종적으로 이벤트는 Ext.app.Controller를 파생한 컨트롤러에 의해 처리되는 표준 "컴포넌트" 이벤트 도메인으로 전달된다.		 	
				 	
		5) 생명주기(Lifecycle)
			: 대형 어플리케이션 개발 시 일반적인 기법은 필요한 상황이 오면 동적으로 컨트롤러를 생성하는 것이다. 
			 이러한 동적 생성기법은 어플리케이션 로딩 시간을 줄여주고, 필요한 모든 컨트롤러를 활성화 하지 않음으로서 실행 시의 성능을 개선하는 효과가 있다.
			 Ext JS 5 이전 버전에서는 한번 컨트롤러가 생성되면 생성된 컨트롤러는 어플리케이션 종료 시까지 계속 살아있게 되는 단점이 있었다.
			 생성된 컨트롤러를 소멸 시키는 것이 불가능 했기 때문에 점유하고 있는 리소스 회수도 불가능 했다. 
			 또한 이전 버전의 컨트롤러는 비현실적으로 연결된 뷰를 아예 갖지 않거나 제한 없는 수로 연결이 가능하기도 했었다.
			 
			  뷰 컨트롤러의 개념이 도입된 Ext JS 5에서는 컴포넌트 생명주기의 가장 처음에 뷰 컨트롤러를 생성하고, 뷰의 전체 생명주기로 그 기간을 한정한다.
			 뷰가 소멸될 때, 뷰 컨트롤러 역시 소멸된다. 이 의미는 뷰 컨트롤러에 대해 연결된 뷰가 전혀 없는지, 혹은 아주 많은지 강제로 그 상태를 관리할 필요가 없다는 것을 뜻한다.
			 
			  이러한 1대1 관계는 레퍼런스 추적이 간소화 되었으며, 소멸된 컴포넌트에 의한 누수가 이제 더 이상 없다는 것을 의미한다. 
			  뷰 컨트롤러의 생명주기 동안 메서드 구현 시 참고할 중요 지점은 다믕과 같다. 
			  		 	
				1) beforeInit - 이 메서드는 뷰의 initComponent 메서드가 호출되기 전에 뷰 조작을 수행하기 원할 때 오버라이드 할 수 있다. 
							   이 메서드는 컴포넌트 생성자가 initConfig 메서드 호출을 수행하는 동안 컨트롤러가 생성되면 즉시 호출된다.
							   
			 	2) init - initCompoonent가 뷰에서 호출되면 조금 있다가 실행된다. 
			 	   		 뷰가 초기화된 후 컨트롤러 초기화를 수행하는 단계
			 	   		 
	 	   		3) initViewModel - 뷰의 뷰 모델이 정의되어 있을 경우, 뷰 모델이 생성되면 호출된다.
	 	   		4) destory - callParent 호출을 통해 인스턴스를 제거하고 리소스를 반환한다. 	
				 	
3. 
				 	
				 	
				 	
				 	
				 	
				 	
				 	
				 	
				 	
				 	
				 	
				 	
				 	
				 	
				 	
				 	
	
	
	
	
	
	