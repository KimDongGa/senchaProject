1. app.json 수정 시 sencha app build를 실행시켜야 한다.


2. app.js : Application.js 파일 내부에서 생성한 클래스를 app.js에서 인스턴스를 실행
	ex)
		Ext.application({
			name : 'Study',
			
			extend: 'Study.Application',
			
			autoCreateViewport :'Study.view.main.Main'  //-> autoCreateViewport는 Ext JS 5의 새로운기능 :
														//	1. autoCreateViewport에 컨테이너 클래스를 설정하게 되면 뷰 포트로 어떤 클래스드니 사용할 수 있게 된다.
															2. autoCreateViewport 설정은 어플리케이션에게 지정된 뷰를 생성하고 뷰포트 플러그인을 덧붙이도록 지시 => 이렇나 동작은 뷰를 document body에 연결하게 된다.			
		})
		
3. Application.js	: - 모든 JS 어플리케이션은 Application 클래스의 인스턴스부터 시작된다. 
					  - 이 클래스는 app.js에 의해 인스턴스가 생성되어 실해오딘다. 아래의 Application.js의 내용은 Sencha Cmd가 자동으로 생성한 것이다.
					  
	ex)
		Ext.define('Study.Application',{ 
			
			extend:'Ext.app.Application',
			name:'Study',
			stores: [
				
			],
			launch: function(){
				
			}
		
		})

4. Views	:- 뷰는 Ext.Component의 서브 클래스인 컴포넌트 그 이상도 그 이하도 아니라고 할 수 있다.
			 - 뷰는 어픞리케이션의 모든 비주얼적 측면을 포함하낟.
			 - "main"폴더의 Main.js파일 
	ex)
		Ext.define('Study.view.main.Main',{
			extend : 'Ext.container.Container',
			xtype : 'app-main',
			controller : 'main',
			viewModel : {
				type : 'main'
			},
			items : [{
				xtype : 'panel',
				bind : {
					title : '{name}'
				},
				region : 'west',
				html : '<ul>...</ul>'
				width : 250,
				split : true,
				sbar : [{
					text : 'Button',
					handler : 'onClickButton'
				}]
			},{
				region : 'center',
				xtype : 'tabpanel',
				items:[{
					title : 'Tab 1',
					html : '<h2>Content ...</h2>'
				}]				
			}]			
		})
5. 컨트롤러 설정
	- 컨트롤러 설정에서는 뷰를 위한 뷰 모델 지정을 수행한다. 
	- 뷰 컨트롤러가 뷰에 대해 지정되면 이벤트 핸들러와 래퍼런스를 위한 컨테이너로 변화
	- 이러한 사실은 결국 뷰 컨트롤러와 뷰에서 이벤트를 발생시키는 컴포넌트가 1-대-1 관계를 갖는다는 뜻.
	
6. 뷰 모델 설정
	- 뷰 모델 설정은 뷰에 대한 뷰 모델을 지정하는 것
	- 뷰 모델은 컴포넌트와 하우 ㅣ뷰에 대한 데이터를 제공하는 역할을 담당한다. 뷰 모델에 담긴 데이터는 컴포넌트와 바인딩 설정에 따라 화면에 전시되거나 편집될 목적으로 사용되는 것이 일반적
	
7. 컨트롤러 (Controller)		
	
	ex)
		Ext.define('Study.view.amin.MainController',{
			extend : 'Ext.app.ViewController',
			requires: [
				'Ext.MessageBox'
			],
			alias : 'controller.main',
			onClickButton : function() {
				Ext.Msg.confirm('Confirm', 'Are you sure', 'onConfirm', this);
			},
			onConfirm : function(){
				if(choice === 'yes'){
				}
			}
		})		
		
	- 뷰 모델 설정은 뷰에 대한 뷰 모델을 지정하는 것		
	- 어플리케이션 뷰를 정의한 Main.js로 돌아가서 살펴본다면 tbar button의 핸들러 처리를 위한 함수가 지정되 있음을 알수 있다.
	- 뷰에 속한 컴포넌트의 이벤트 핸들러인 onClickButton함수는 바로 이 컨트롤러에 정의되어 있다.
	- 컨트롤러는 별다른 특별한 설정이 없이 이벤트를 처리할 준비가 되어 있다.
	- 이런 점은 어플리케이션에 매우 쉽게 로직을 추가할 수 있게 된다.
	- onClickButton함수에 필요한 몯느 것ㅇ느 여기에 구현하면 되는데 바로 컨트롤러가 뷰와 1대1관계로 대응하기 때문
	- 목적 
		: 1. "listeners"와 "reference" 설정을 이용한 뷰와 연결
		  2. 연결된 뷰 컨틀롤러를 자동으로 관리함으로서 뷰의 생명주기를 연장, 인스턴스 생성부터 소멸에 이르기까지 Ext.app.ViewwController는 
		  	컴포넌트와 이를 참조하는 뷰 컨트롤러를 묶어주는데 같은 뷰 클래스의 두번째 인스턴스는 자신만의 뷰 컨트롤러 인스턴스를 갖게 된다. 
		  	 이러한 뷰가 소멸될 때 연결된 뷰 컨트롤러 인스턴스 역시 같이 소멸
		  3. 중첩된 뷰의 직관성을 위한 추상화 제공
	
8. 뷰 모델
	
	ex) 
		Ext.define('Study.view.main.MainModel',{
			extend : 'Ext.app.ViewModel',
			alias : 'viewmodel.main',
			data: {
				name:'Study'				
			}
		})
	- 뷰 모델은 데이터 객체를 관리하는 클래스이다.
	- 이 클래스는 뷰가 사용할 데이터를 바인딩하고 데이터가 수정되었을 때 알리는 역할을 수행한다.
	- 뷰 컨트롤러와 유사하게 뷰 모델은 래퍼러스를 이용해서 뷰에 연결된다. 뷰 모델이 뷰와 연결되어 있기 때문에 컴포넌트 계층구조의 조상 컴포넌트에 의해 
	 소유된 상위 부모 뷰 모델과 연결되는 것 역시 가능하다. 
	- 이러기에 자식 뷰는 간단하게 부모 뷰 모델의 데이터를 "상속"할 수 있다.
	- Main.js의 뷰 모델 설정을 이용해서 뷰와 뷰 모델의 연결을 생성하였다. 이 연결은 뷰 모델로부터 뷰로 서넝ㄴ적인 형태로서 데이터르 자동으로 설정하기 위한 Setter와 설정을 
	
	
	
	
	
	
	
	
	
	
	
	
	