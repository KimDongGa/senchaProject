1. 접근성 

1-1. 소개 
	: Ext JS 5에서는 Section 508 및 ARIA 규약준수가 필요한 개발자들에게 필요한 도구를 제공항으로서 높은 수준의 접근성을 갖는 어플리케이션 개발이 가능하도록 했다.
	
1-2. 접근성 개요
	: 소프트웨어에서 접근성은 무엇을 의미하는가? 일반적으로, 접근성은 어플리케이션의 기능과 컨텐츠가 다음 대상에게 제공되는 것을 의미한다.
	
	- 시각적으로 장애를 갖는 사람
	- 컴퓨터 사용을 위해 스크린 리더와 같은 보조 장치에 의존하는 사람
	- 어플리케이션 탐색을 위해 마우스 사용이 불가능 한 사람
	
	: 1998년, 미국 의회는 "Section 508 Amendment to the Rehabilitation Act of 1973"을 통과시켰다. 이 법은 섹션 508로 더 잘 알려져 있는데, 모든 연방 기구는 장애를 갖는 이들이 읽을 수 있도록 전자정보를 생성하도록 규정하고 있다.
	 섹션 508 접근성은 미 정부 기관에서 사용하는 어플리케이션을 개발하느 모든 이들이 준수해야할 요구사항이 되었다.
	  웹 어플리케이션의 경우 Web Accessibility Initialtive's의 가이드라인을 준수함으로서 섹션 508 호환성 확보에 획지적인 발전을 가져오게 되었다. 그 가이드라인이 바로 ARIA로서 WAI-ARIA라고도 불리우며 본래 명칭은 
	 Accessible Rich Internet Application Suite이다.

1-3. Ext JS의 접근성
	: Ext JS의 내장 탭 인덱싱과 포커스 관리 능력에 힘입어 브라우저에서 탭과 포커스는 사용자가 기대하는 바를 충족한다. 이러한 접근방법에 기반하여 센차 개발진은 컴포넌트를 디폴트 키보드 네비게이션 행위로 수용가능한 아이템으로 변환하기 위해 노력했다.
	  Ext JS 5의 접근성 지원은 포커스를 통한 키포드 네비게이션과 DOM 속성 두가지에 중점을 두고 설계 되었다. Ext JS 5.0.1에서는  포커스와 키보드 네비게이션 기능은 focusable로 알려져 있는 클래스 수준 속성에 따라 "항상 가능" 상태이다.
	  포커스는 개발자에 의해 업그레이드에 따라 추가적인 변경이 필요없다.
	
	1). 포커스 스타일링(Focus Styling)
		: 포커스 스타일링은 키보드 이벤트나 다른 사용자 입력을 수용하기 위해 준비된 엘리먼트에 대해 시각적 알림(Visually Indicationg) 방법에 관한 것으로 설명된다. 시각적 알림은 접근성 확보와 일부 키보드 네비게이션에 완전히 의존하는 파워 유저들을
		 대상으로 필수적이며 그만한 가치가 있다.
		  프레임워크는 현재 포커스 된 컴포넌트 혹은 변경된 컴포넌트에 대한 명확한 알림을 제공한다. 이 시각적 알림은 포커스 된 컴포넌트의 내부 테두리(Inner Border)와 본체 테두리(Body Border)의 변화를 이용하게 되며 어플리케이션 테마에 따라 다소
		 표현하는 방식은 다를 수 있다. 이러한 시각적 측면의 변화를 제어하기 위해 포커스에 관한 여러개의 Sass변수와 믹스인 파라미터를 사용할 수 있다.
		 
	2). 버튼
		: 이전 버전에서 버튼의 포커스 스타일링은 hover 스타일로 일부 유저들에게 혼란을 야기했었다. 버전 5.0.1에서 버튼은 "inner"테두리 방식으로 포커스 스타일링을 변경헀다. Neptune 및 Crisp 테마에서는 버튼의 외곽선 내부에 1px짜리 실선 경게를 그리는
		 방식을 취했다.
		  클래식 테마에서는 포커스 테두리는 "Windows" 스타일과 유사하게 버튼의 내부 요소 주위로 점선을 그리는 방식이다.
		  포커스된 버튼에 호버, 호버 상태에서 눌림 상태에 대한 스타일링 변경이 필요할 수 있다. 이를 위해 2가지 추가적인 버튼 상태, 즉 "focus-over"와 "focus-pressed"에 대한 Sass 변수를 추가했으므로 필요 시 이 두 변수를 적당히 수정하면 된다.

	3). 탭
		: 탭은 과거에 포커스에 대한 시각적 알림 기능이 없었다. Ext JS 5.0.1에 와서야 탭은 버튼과 유사헥 취급되기 시작했다. Neptune/Crisp테마에서는 실선 내부 테두리로, 클래식 테마에서는 점선 외관선 형태로 포커스를 표시한다. Crisp:
		
		  Classic:
		
		  버튼과 마찬가지로 "focus-over", "focus-active" 상태를 제어하기 위한 SASS 변수도 준비되어 있다.
		  
   4). 그리드
   		: 포커스 된 그리드 셀은 아래와 같이 명확한 포커스 스타일링을 갖는다. 추가적으로 그리드 컬럼 헤더는 아래 예에서 볼 수 있느 것과 같이 돍립적인 포커스를 갖을 수 있다.
   		
   5). 포커스 스타일링과 커스터마이징
   		: 키보드 네비게이션은 좀 더 많은 사용자들을 배려함으로서 다양한 어플리케이션에서 각광받을 것으로 기대되는 기능이다. 동시에 모든 어플리케이션의 제각기 다른 요구사항 충족을 위해 Sass 변수 및 믹스인에 기반한 API를 사용하는 컴포넌트라면 스타일의
   		 커스터마이징이 가능하도록 헀다.
   		  포커스 스타일링이 가능한 모든 변수는 변수 이름에 "focus"라는 키워드를 사용하고 있으므로 식별하기 쉽다. 어떤 컴포넌트에 대한 스타일을 변경하고 싶을 경우 클래스 문서의 "CSS Variables" 섹션을 찾아보자
   		  예를 들어, "default" 버튼 UI의 포커스 테두리 스타일을 바꾸고 싶을 경우, $button-default-inner-border-color-focus Sass이란 변수를 사용하고 있을 것이다. 어플리케이션에서 Sass를 활용하는 방법은 Theming Guide를 참고하라.
   
   6). 키보드 네비게이션
   		: 어플리케이션의 포커스 가능한 컴포넌트는 마우스 없이 완전히 커보드만으로 포커스 이동이 가능하다. Ext JS 관점에서 이것은 Tab 키를 누르면 URL 바로부터 시작해서 어플리케이션 도큐먼트 바디에 포함된 다음번 포커스 가능한 컴포넌트로 포커스가 이동하게 됨을 
   		 의미한다.
   		  그러나 툴 바와 같은 일부 컴포넌트는 약간 다른 포커스 특성을 갖고 있어서 Tab키는 툴 바 사이를 이동하고 툴 바 내부 이동은 화살표 키를 사용해야 하낟. 이것은 WAi-ARIA 표준에 따라 과도한 Tab키 사용을 피해 사용성을 보장하기 위한 것이다.
   		  예를 들어 여러 개의 버튼을 포함한 두 개의 툴 바를 보면, Tab키를 한 번 누르면 위에서 보는 것과 같이 버튼1에 포커스가 이동할 것이다. 다시 한번 Tab키를 누르면 포커스 이동 가능한 다음 컴포넌트로 포커스가 이동할 것이다. 이와 같은 경우 다음번 포커스가
   		 가능한 아이템은 버튼, 탭, 폼 필드, 그리드 등이 있다.
   		  또한 포커스의 역방향 이동을 위해서는 "Shift+Tab"을 이용하면 탭 인덱스의 역방향 탐색이 가능하다. 위 예에서 툴 바 내부의 아이템 탐색을 위해서는 화살표 키를 이용해서 툴 바 내부 버튼을 이동할 수 있고 마지막 버튼 4까지 이동한 경우 다시 버튼 4까지
   		 이동한 경우 다시 버튼 1로 이동하는 순환 구조가 된다.
   		  만약 툴 바에서 포커스를 이동시키기 위해서 Tab키를 누르고 다시 Shift+Tab을 누르면 프레임워크는 마지막에 포커스를 갖고 있던 버튼에 포커스를 이동시킨다. 이는 툴 바와 다른  포커스 기능 컨테이너에 대한 상태를 내부적으로 관리하기 때문에 가능하다.
   		  주의). 입력 필드로 진입하면 화살표 키 네비게이션은 당연히 그 입력 필드 내부에서만 작동하게 된다. 다른 컴포넌트로 이동을 위해서는 Tab 똔느 Shift+Tab으로 입력 필드에서 빠져나와야 한다.
   
   7). DOM 속성
   		: 컴포넌트의 DOM 속성은 엘리먼트 타입, 상태 및 설명에 대한 의미있는 정보제공을 위해 반드시 속성(Attribute)를 사용해야 한다. 이런 속성들은 스크린 리더와 같은 보조 기술(Assistive Technology)에 의해 사용되어 사용자에게 음성 신호를 제공하는데,
   		 2개의 서로 분리된 그룹으로 분류할 수 있다.
   
   8). ARIA 롤(Roles)
   		: ARIA 롤은 컴포넌트 또는 엘리먼트 타입의 주 표시자로서 영구적이고 컴포넌트와 사용자의 상호작용에 의해 변경되지 않는다. Ext JS에서 ARIA 롤이 대표적으로 사용되는 것은 위젯 롤이다. 위젯 롤은 대부분은 Ext JS  컴포넌트와 일치하며 예로서 그 일부는
   		 다음과 같다.
   		 
   		 - 툴 바(Toolbar)
   		 - 탭 바와 탭(Tab bars and tabs)
   		 - 체크박스(Checkboxes)
   		 - 라디오 버튼(Radio Buttons)
   		 - 버튼(Buttons)
   		 - Breadcrumb Groups 
   
   9). ARIA 상태(States) 및 속성들(Properties)		
		: DOM 속성들은 사용자의 조작이나 어플리케이션 상태에 따라 변경될 수 있는 속성들이다. ARIA 상태(State)의 예는 체크박스에 적용된 "aria-checked" 속성을 들 수 있다. 유사하게 ARIA 소것ㅇ(Property)은 폼 필드로 validation 혹은 사용자 입력에 의해 
		 동적으로 변경될 수 있는 "aria-invalid" 속성을 예로 들 수 있다.
		  ARIA 상태 및 속성을 활성화 하는 방법은 아래 ARIA 패키지 내용에서 상세하게 기술하였다.
		
1-4. ARIA 패키지
	: "ext-aria" 패키지는 분리된 Cmd 패키지로서 ARIA 상태 및 속성을 지원하기 위해 제공된다. "Ext-aria"패키지는 app.json에 포함될 수 있고 다른 패키지와 별도로 분리되어야 한다.
	
	ex)
		 "requires" : {
		 	"ext-aria"
		 }, 
	
	# app.json 파일을 수정하고 나면 어플리케이션을 리빌드 해야한다. 빌드가 완료되면, 위에서 설명한 ARIA상태 및 속성이 컴포넌트에 부여된다.
	# 또한 만약 "ext-theme-aria" 테마를 사용해서 어플리케이션을 작성했다면 "ext-aria" 패키지를 직접 app.json에 포함 시킬 필요는 없다. 'ext-theme-aria'는 'ext-aria' 패키지를 기본으로 사용하는데, 'ext-theme-aria'를 사용하는 방법에 대해서는
	 다음 섹션에서 다루기로 하자.
	# 주의) 위에서 설명한 어플리케이션 빌드에 대해 모르겠다면, 센차의 Getting Started Guide를 참고. 

1-5. ARIA 테마	  	 
	: "ext-theme-aria"는 시각적 장애를 갖는 사용자를 위한 고대비 테마로서 사용자 설정에 따라 look&feel 변경이 가능하다. Ext JS ARIA 테마를 어플리케이션에 적용하기 위해서는 app.json의 테마 블럭을 다음과 같이 수정하면 된다.
	
	ex)
		"theme" : "ext-theme-neptune",
	# 위는 아래와 같이 바뀌어야 한다.
	
	ex)
		"theme" : "ext-theme-aria",
	# app.json 파일이 수정되었으므로 어플리케이션을 다시 빌드하고나면 어플리케이션은 'ext-theme-aria'테마가 적용되어 아래와 같을 것이다.
	 
2. 클래스 시스템
	: 이 장에서는 Ext JS 4.x와 5.x에서 사용하는 기존 클래스를 확장하거나 새로운 클래스를 만들기 위한 내용을 설명한다.
2-1. 개요
	 : Ext JS 5는 300개 이상의 클래스로 구성되어 있다. Ext JS를 사용하는 개발자는 2백만 이상으로 다양한 배경과 위치에 분포한다. 이러한 구도에서 센차 개발진은 다음과 같은 일반적 코드 아키텍처를 제공해야 하는 큰 도전에 직면했었다.
	 
	 - 친숙하고 배우기 쉬울 것
	 - 빠른 개발, 쉬운 디버그, 고통 없는 배포
	 - 조직되고 확장가능하면 유지보수 가능
	 
	 : 자바 스크립트는 클래스가 없고 프로토타입 지향적(Prototype-oriented) 언어이기 때문에 한가지 강력한 기능이라면 바로 유연함이 될 것이다. 서로 다른 코딩 스타일과 기법을 사용함으로해서 발생되는 문제를 해결하는 방법은 다양하지만, 
	  예측불가능한 비용과 함께라면 곤란할 것이다. 또한 통일되지 않은 구조의 자바스크립트 코드는 재사용, 유지보수 및 이해가 어려운 것은 잘 알려진 사실이다.
	   반면에 클래스 기반 프로그래밍은 객체지향 프로그래밍의 가장 대중적인 모델로서, 클래스 기반 언어들은 일반적으로 변수 형식에 대한 강한 제약(strong-typing), 캡슐화, 표준 코딩 규칙 등을 요구한다. 개발자에 의해 더해진 이런 저런 원칙들로 인해서
	  코드는 향후 예측, 확장성 등을 시간의 흐름에 따라 갖게 되는데 이러한 모델은 자바스크립트가 갖는 동적인 능력은 보유하지 못한다.
	   각각의 접근 방식은 장단점이 있지만 양쪽의 나쁜 부분은 숨기고 좋은 점만 취할 수 있지 않을까? 센차의 대답은 그렇다로서 그 Ext JS에서 그 해답을 찾을 수 있을 것이다.

2-2. 명명 규칙(Naming Conventions)
	: 코드에서 클래스, 네임스페이스, 파일이름 등에 걸쳐 일관된 명명 규칙을 사용하는 것은 코드를 잘 조직화하고 구조화하며 가독성을 높이는데 도움을 준다.
	
	1) 클래스
		: 클래스 이름은 알파벳 및 숫자(alphanumeric)만 사용할 수 있으며, 기술적 용어에 포함된 숫자를 제외하고 숫자는 허용되지만 권장되지는 않는다. "_"(언더스코어), "-"(하이픈)과 알파벳 및 숫자가 아닌 문자는 클래스 이름으로 사용할 수 없다. 
		 예를 들면 다음과 같다.
		 
		 - MyCompany.useful_util.Debug_Toolbar // 사용 불가
		 - MyCompany.util.Base64 // 사용 가능
		
		: 클래스 이름은 적정한 네임스페이스를 명시하는 객체 속성 점 표시법(Object property dot-notation)에 의해 (.)으로 구분되어 패키지에 그룹으로 묶어야 하며, 최소한 하나의 유니크한 최상위 네임 스페이스에 속해야 한다. 에를 들면.
		
		ex) 
			MyCompany.data.CoolProxyMyCompany.Application
		
		# 최상위 네임 스페이스와 실제 클래스 이름은 카멜 표기법을 따라야 한다.	 
		
		ex) 
			MyCompany.form.action.AutoLoad
		
		# 센차에서 배포하지 않는 클래스는 절대 최상위 네임 스페이스로 Ext를 사용할 수 없다. 축약어 역시 위에서 설명한 카멜 표기법에 따라서 작성한다.
		
	2) 소스 파일
		: 클래스 맵의 이름은 직접적으로 저장되는 파일 경로를 나타낸다. 그 결과로 반드시 파일 하나당 한 클래스만 포함해야 한다.
		
		- Ext.util.Observable 클래스는 path/to/src/Ext/util/Observable.js에 저장되고
		- Ext.form.action.Submit 클래스는 path/to/src/Ext/form/action/Submit.js
		- MyCompany.chart.axis.Numeric은 path/to/src/MyCompany/chart/axis/Numeric.js
		
		# 위에서  path/to/src는 어플리케이션 클래스의 디렉토리 경로를 의미한다. 모든 클래스는 최적의 개발, 유지보수 및 배포를 위해 반드시 위의 저장 규칙과 네임 스페이스 규칙을 준수해야 한다.
	
	3) 메서드와 변수
		- 클래스 이름과 비슷한 유형으로 메서드와 벼수 이름도 알파벳 및 숫자(alphanumeric)로만 구성되어야 한다. 기술적 용어로서 숫자를 제외하고 숫자는 허용은 되지만 권장되는 않는다. 언더스코어(_), 하이픈(-) 및 알파벳/숫자를 제외한
		 다른 문자는 사용할 수 없다.
		- 메서드 및 변수 이름은 항상 카멜 표기법에 따라야 한다. 축약어도 마찬가지다.
	
		예제)
			3-1) 허용되는 메서드 이름 :
				- encodeUsingMd5()
				- getHtml()
				- getJsonResponse()
				- parseXmlContent()
			3-2) 허용되는 변수 이름 :
				- var isGoodName
				- var base64Encoder
				- var xmlReader
				- var httpServer
				 
	5) 속성
		- 클래스 속성 이름은 상수(static constants)일 경우를 제외하고 위에서 설명한 규칙을 그대로 따른다.
		- 상수 클래스 속성은 반드시 모두 대문자로 표기한다. 예를 들면,
			5-1) Ext.MessageBox.YES = "YES"
			5-2) Ext.MessageBox.NO = "NO"
			5-3) MyCompany.alien.Math.PI = "4.13"
	
2-3. 선언
	1) 예전 방식
		: Ext JS 4버전까지의 이전 버전을 사용하고 있다면 필시 다음과 같이 클래스 생성을 위한 Ext.exend 사용이 친숙할 것이다.
		
		ex)
			var MyWindow = Ext.extend(Object, {...});
		
		# 이 방식은 어떤 클래스로부터 파생하여 새로운 클래스를 생성할 때 손쉬운 방식이다. 클래스를 생성할 때 직접적인 상속을 대신할만한 다른 유연한 API를 갖지 못한것도 사실이다. 이번 챕터에서는 설정, 상수, 믹스인 같은 것들은 제외하고 나중에 
		 다루기로 하자. 다른 샘플을 보자
		
		ex)
			My.cool.Window = Ext.extend(Ext.Window,{...});
		
		# 이 예제에서는 새로 만들 클래스에 네임 스페이스를 사용하고, Ext.Window 클래스를 상속하고 있다. 여기에 우리가 다루고자 하는 두가지 주제가 있다. 
			1-1) My.cool은 Window를 속성으로 할당하기 전에 미리 존재하는 객체를 필요로 한다.
			1-2) Ext.Window는 참조 가능한 상태 이전에 페이지에서 객체가 존재하고 로딩이 완료되어 있어야 한다.
			
		# 첫번째 문제는 보통 Ext.namespace(줄여서 Ext.ns)를 통해 해결 가능하다. 이 방법은 객체와 속성 트리를 검사해서 없다면 생성해 준다. 참고로 Ext.ns를 사용하는 방법은 Ext.extend가 나오기 전에 적용되어야 한다.
		
		ex) 
			Ext.ns('My.cool');
			My.cool.Window = Ext.extend(Ext.Window, {...});
			
		# 두번째 이슈는 Ext.Window가 많은 다른 클래스에 의존성을 갖을 수 있기 때문에 쉽게 해결할 수 있는 문제는 아니라는 점이다. 이러한 의존성 문제는 다른 클래스의 존재 유무에 따라 의존적이기 때문에 Ext JS 4 이전에 작성된 어플리케이션
		 코드들은 ext-all.js 형태로 라이브러리 전체를 include 해버렸다. 비록 프레임워크의 아주 일부분만 필요로 할지라도 말이다.
	
	2) 새로운 방식
	3) 설정(Configuration)
	4) 상수 멤버(Statics)
	
2-4. 에러 핸들링 & 디버깅


3. 컴포넌트

4. 데이터 패키지

5. 드래그 & 드롭

6. 이벤트

7. 레이아웃과 컨테이너

8. 혀닞화

9. 메모리 누수 식별

10. RTL 지원

11. 태블릿 지원

12. 테마

13. 그리기 패키지	 



	 
	 
	 